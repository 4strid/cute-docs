/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib/cute.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/array-flatten/array-flatten.js":
/*!*****************************************************!*\
  !*** ./node_modules/array-flatten/array-flatten.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Expose `arrayFlatten`.\n */\nmodule.exports = flatten\nmodule.exports.from = flattenFrom\nmodule.exports.depth = flattenDepth\nmodule.exports.fromDepth = flattenFromDepth\n\n/**\n * Flatten an array.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flatten (array) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFrom(array)\n}\n\n/**\n * Flatten an array-like structure.\n *\n * @param  {Array} array\n * @return {Array}\n */\nfunction flattenFrom (array) {\n  return flattenDown(array, [])\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDepth (array, depth) {\n  if (!Array.isArray(array)) {\n    throw new TypeError('Expected value to be an array')\n  }\n\n  return flattenFromDepth(array, depth)\n}\n\n/**\n * Flatten an array-like structure with depth.\n *\n * @param  {Array}  array\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenFromDepth (array, depth) {\n  if (typeof depth !== 'number') {\n    throw new TypeError('Expected the depth to be a number')\n  }\n\n  return flattenDownDepth(array, [], depth)\n}\n\n/**\n * Flatten an array indefinitely.\n *\n * @param  {Array} array\n * @param  {Array} result\n * @return {Array}\n */\nfunction flattenDown (array, result) {\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (Array.isArray(value)) {\n      flattenDown(value, result)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Flatten an array with depth.\n *\n * @param  {Array}  array\n * @param  {Array}  result\n * @param  {number} depth\n * @return {Array}\n */\nfunction flattenDownDepth (array, result, depth) {\n  depth--\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i]\n\n    if (depth > -1 && Array.isArray(value)) {\n      flattenDownDepth(value, result, depth)\n    } else {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXJyYXktZmxhdHRlbi9hcnJheS1mbGF0dGVuLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5LWZsYXR0ZW4vYXJyYXktZmxhdHRlbi5qcz8wNmU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEV4cG9zZSBgYXJyYXlGbGF0dGVuYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuXG5tb2R1bGUuZXhwb3J0cy5mcm9tID0gZmxhdHRlbkZyb21cbm1vZHVsZS5leHBvcnRzLmRlcHRoID0gZmxhdHRlbkRlcHRoXG5tb2R1bGUuZXhwb3J0cy5mcm9tRGVwdGggPSBmbGF0dGVuRnJvbURlcHRoXG5cbi8qKlxuICogRmxhdHRlbiBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuIChhcnJheSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgYW4gYXJyYXknKVxuICB9XG5cbiAgcmV0dXJuIGZsYXR0ZW5Gcm9tKGFycmF5KVxufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW4gYXJyYXktbGlrZSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkZyb20gKGFycmF5KSB7XG4gIHJldHVybiBmbGF0dGVuRG93bihhcnJheSwgW10pXG59XG5cbi8qKlxuICogRmxhdHRlbiBhbiBhcnJheS1saWtlIHN0cnVjdHVyZSB3aXRoIGRlcHRoLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgYXJyYXlcbiAqIEBwYXJhbSAge251bWJlcn0gZGVwdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuRGVwdGggKGFycmF5LCBkZXB0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsdWUgdG8gYmUgYW4gYXJyYXknKVxuICB9XG5cbiAgcmV0dXJuIGZsYXR0ZW5Gcm9tRGVwdGgoYXJyYXksIGRlcHRoKVxufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW4gYXJyYXktbGlrZSBzdHJ1Y3R1cmUgd2l0aCBkZXB0aC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIGFycmF5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRlcHRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkZyb21EZXB0aCAoYXJyYXksIGRlcHRoKSB7XG4gIGlmICh0eXBlb2YgZGVwdGggIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIGRlcHRoIHRvIGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIHJldHVybiBmbGF0dGVuRG93bkRlcHRoKGFycmF5LCBbXSwgZGVwdGgpXG59XG5cbi8qKlxuICogRmxhdHRlbiBhbiBhcnJheSBpbmRlZmluaXRlbHkuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkRvd24gKGFycmF5LCByZXN1bHQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZsYXR0ZW5Eb3duKHZhbHVlLCByZXN1bHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGFuIGFycmF5IHdpdGggZGVwdGguXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9ICByZXN1bHRcbiAqIEBwYXJhbSAge251bWJlcn0gZGVwdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuRG93bkRlcHRoIChhcnJheSwgcmVzdWx0LCBkZXB0aCkge1xuICBkZXB0aC0tXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldXG5cbiAgICBpZiAoZGVwdGggPiAtMSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZmxhdHRlbkRvd25EZXB0aCh2YWx1ZSwgcmVzdWx0LCBkZXB0aClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/array-flatten/array-flatten.js\n");

/***/ }),

/***/ "./node_modules/deep-equal/index.js":
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(/*! ./lib/keys.js */ \"./node_modules/deep-equal/lib/keys.js\");\nvar isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ \"./node_modules/deep-equal/lib/is_arguments.js\");\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2luZGV4LmpzPzdmYWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deep-equal/index.js\n");

/***/ }),

/***/ "./node_modules/deep-equal/lib/is_arguments.js":
/*!*****************************************************!*\
  !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcz85OTdkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deep-equal/lib/is_arguments.js\n");

/***/ }),

/***/ "./node_modules/deep-equal/lib/keys.js":
/*!*********************************************!*\
  !*** ./node_modules/deep-equal/lib/keys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzPzMyNjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deep-equal/lib/keys.js\n");

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QvcXVpY2tzZWxlY3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QvcXVpY2tzZWxlY3QuanM/NjFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwucXVpY2tzZWxlY3QgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgICBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0IHx8IDAsIHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSksIGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmUpO1xufVxuXG5mdW5jdGlvbiBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gYXJyW2tdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5cbnJldHVybiBxdWlja3NlbGVjdDtcblxufSkpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFVBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/quickselect/quickselect.js\n");

/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = __webpack_require__(/*! quickselect */ \"./node_modules/quickselect/quickselect.js\");\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanM/MDM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmJ1c2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcmJ1c2g7XG5cbnZhciBxdWlja3NlbGVjdCA9IHJlcXVpcmUoJ3F1aWNrc2VsZWN0Jyk7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgY29sbGlkZXM6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRm4pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGNvbXBhcmVOb2RlTWluWCxcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtIDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJyxcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcbiAgICAgICAgICAgICcsIG1heFg6IGEnICsgZm9ybWF0WzJdICtcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpLFxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXG4gICAgICAgICAgIGEubWluWSA8PSBiLm1pblkgJiZcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/rbush/index.js\n");

/***/ }),

/***/ "./src/lib/constructor.js":
/*!********************************!*\
  !*** ./src/lib/constructor.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction Constructor(plan, ...wrappers) {\n\tconst prototype = Object.create(Constructor.prototype);\n\n\tconsole.log(wrappers);\n\n\t// attach render function\n\tif (wrappers.length) {\n\t\tlet render = plan.render;\n\t\tfor (let i = wrappers.length - 1; i >= 0; i--) {\n\t\t\tconst renderFn = render;\n\t\t\trender = function () {\n\t\t\t\treturn wrappers[i].call(this, renderFn.bind(this), this, this.props);\n\t\t\t};\n\t\t}\n\t\tprototype.render = render;\n\t} else {\n\t\tprototype.render = plan.render;\n\t}\n\t// attach methods from plan\n\tfor (const method in plan.methods) {\n\t\tprototype[method] = plan.methods[method];\n\t}\n\t// attach State transitions from plan\n\tfor (const state in plan.states) {\n\t\tprototype[state] = function () {\n\t\t\tthis.node.removeEventListeners(this);\n\t\t\tthis.state.set(state);\n\t\t\tplan.states[state].call(this);\n\t\t};\n\t}\n\n\tif (plan.update) {\n\t\tprototype.update = plan.update;\n\t}\n\n\tprototype.destroy = function () {\n\t\tif (plan.destroy) {\n\t\t\tplan.destroy.call(this);\n\t\t}\n\t};\n\n\tprototype.construct = function (props) {\n\t\tthis.props = {};\n\t\tfor (const k in props) {\n\t\t\tif (k === 'key' || k === 'ref' || k === 'proxy') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.props[k] = props[k];\n\t\t}\n\t\t// pass the transform value up to the node\n\t\tprops.transform = plan.transform !== false;\n\n\t\t// the canonical data object that actually holds the data\n\t\tconst data = {};\n\n\t\t// set initial positional values\n\t\tObject.assign(data, {\n\t\t\tx: props.x || plan.x || 0,\n\t\t\ty: props.y || plan.y || 0,\n\t\t\tw: props.w || plan.w,\n\t\t\th: props.h || plan.h\n\t\t});\n\n\t\t// proxy data object whose getters and setters allow for automatic rerendering\n\t\tthis.data = {};\n\n\t\t// do x, y, w, and h first so they're available in the plan.data function\n\t\tfor (const k in data) {\n\t\t\tObject.defineProperty(this.data, k, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn data[k];\n\t\t\t\t},\n\t\t\t\tset: val => {\n\t\t\t\t\tdata[k] = val;\n\t\t\t\t\tthis.node.scheduleRender();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// allow for moving the component without rerendering it\n\t\tfor (const k of ['x', 'y']) {\n\t\t\tObject.defineProperty(this, k, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn data[k];\n\t\t\t\t},\n\t\t\t\tset: val => {\n\t\t\t\t\tif (val !== data[k]) {\n\t\t\t\t\t\tdata[k] = val;\n\t\t\t\t\t\tthis.node.scheduleMove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (plan.data) {\n\t\t\tconst planData = plan.data.call(this);\n\n\t\t\tfor (const k in planData) {\n\t\t\t\tdata[k] = planData[k];\n\t\t\t\tObject.defineProperty(this.data, k, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tget() {\n\t\t\t\t\t\treturn data[k];\n\t\t\t\t\t},\n\t\t\t\t\tset: val => {\n\t\t\t\t\t\tdata[k] = val;\n\t\t\t\t\t\tthis.node.scheduleRender();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (props.proxy) {\n\t\t\tprops.proxy((proxied, ...bindings) => {\n\t\t\t\tthis.proxyOf = proxied;\n\t\t\t\tfor (const binding of bindings) {\n\t\t\t\t\tObject.defineProperty(this, binding, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tget() {\n\t\t\t\t\t\t\treturn proxied[binding];\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset(value) {\n\t\t\t\t\t\t\treturn proxied[binding] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// oh cool, actually the order of events is:\n\t\t//  - parent component changes state\n\t\t//   > schedules rerender\n\t\t//  - child component does not have NewState, so it calls Ready instead\n\t\t//  - rerender occurs, child receives NewState\n\t\t//\n\t\t//  so problem... averted for now\n\t\tlet startState = 'Ready';\n\t\tif (props.state && this[props.state.name]) {\n\t\t\tstartState = props.state.name;\n\t\t}\n\n\t\tthis.state = new State(startState, this);\n\t};\n\n\tconst constructor = plan.hasOwnProperty('constructor') ? plan.constructor : function Component(props) {\n\t\tthis.construct(props);\n\t};\n\n\tif (plan.transform === false) {\n\t\tconstructor.transform = false;\n\t}\n\tconstructor.prototype = prototype;\n\tconstructor.prototype.constructor = constructor;\n\n\treturn constructor;\n}\n\nConstructor.prototype = {\n\t// listen for a certain evtype. handler is removed upon state change\n\ton(evtype, handler) {\n\t\tthis.node.addEventListener(this, evtype, handler);\n\t},\n\t// listen for a certain evtype. handler persists through state changes\n\tlisten(evtype, handler) {\n\t\tthis.node.addPersistentListener(this, evtype, handler);\n\t},\n\t// removes a persistent listener\n\tunlisten(evtype) {\n\t\tthis.node.removePersistentListener(this, evtype);\n\t},\n\tgetCollisions() {\n\t\treturn this.node.getCollisions(this);\n\t},\n\t// sets own state to the given name and attempts to call that state function\n\tsetState(name) {\n\t\tthis.state.set(name);\n\t\tif (this[name]) {\n\t\t\tthis[name]();\n\t\t}\n\t\tthis.node.scheduleRender();\n\t},\n\t_receiveProps(props) {\n\n\t\tfor (const k of ['x', 'y', 'w', 'h']) {\n\t\t\tif (props[k] !== undefined && props[k] !== this.props[k]) {\n\t\t\t\t// call getters / setters to act appropriately\n\t\t\t\tthis[k] = props[k];\n\t\t\t}\n\t\t}\n\n\t\tfor (const p in props) {\n\t\t\tthis.props[p] = props[p];\n\t\t}\n\t\t//this.props = props\n\n\t\t// if state has changed, call the state transition function\n\t\tif (props.state && props.state.isUpdated) {\n\t\t\tthis.setState(props.state.name);\n\t\t}\n\t}\n};\n\n// attach w, h convenience getters and setters\n// w and h should trigger a rerender\n// these are common among all components so we attach them to Constructor.prototype\n//\nfor (const k of ['w', 'h']) {\n\tObject.defineProperty(Constructor.prototype, k, {\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this.data[k];\n\t\t},\n\t\tset(val) {\n\t\t\tthis.data[k] = val;\n\t\t\treturn val;\n\t\t}\n\t});\n}\n\nfunction State(name, component) {\n\tthis[name] = true;\n\tthis.name = name;\n\tthis.component = component;\n\tthis.stack = [];\n}\n\nState.prototype.set = function (name) {\n\tthis[this.name] = undefined;\n\tthis[name] = true;\n\tthis.name = name;\n\tthis.isUpdated = true;\n};\n\nState.prototype.save = function () {\n\tthis.stack.push(this.name);\n};\n\nState.prototype.restore = function () {\n\tconst name = this.stack.pop();\n\tif (name === undefined) {\n\t\tthrow new ReferenceError('Tried to restore state with no states on the stack');\n\t}\n\tthis.component.setState(name);\n};\n\n//Constructor.prototype.constructor = Constructor\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Constructor);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL2NvbnN0cnVjdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9saWIvY29uc3RydWN0b3IuanM/YzUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBDb25zdHJ1Y3RvciAocGxhbiwgLi4ud3JhcHBlcnMpIHtcblx0Y29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb25zdHJ1Y3Rvci5wcm90b3R5cGUpXG5cblx0Y29uc29sZS5sb2cod3JhcHBlcnMpXG5cblx0Ly8gYXR0YWNoIHJlbmRlciBmdW5jdGlvblxuXHRpZiAod3JhcHBlcnMubGVuZ3RoKSB7XG5cdFx0bGV0IHJlbmRlciA9IHBsYW4ucmVuZGVyXG5cdFx0Zm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCByZW5kZXJGbiA9IHJlbmRlclxuXHRcdFx0cmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQgcmV0dXJuIHdyYXBwZXJzW2ldLmNhbGwodGhpcywgcmVuZGVyRm4uYmluZCh0aGlzKSwgdGhpcywgdGhpcy5wcm9wcylcblx0XHRcdH1cblx0XHR9XG5cdFx0cHJvdG90eXBlLnJlbmRlciA9IHJlbmRlclxuXHR9IGVsc2Uge1xuXHRcdHByb3RvdHlwZS5yZW5kZXIgPSBwbGFuLnJlbmRlclxuXHR9XG5cdC8vIGF0dGFjaCBtZXRob2RzIGZyb20gcGxhblxuXHRmb3IgKGNvbnN0IG1ldGhvZCBpbiBwbGFuLm1ldGhvZHMpIHtcblx0XHRwcm90b3R5cGVbbWV0aG9kXSA9IHBsYW4ubWV0aG9kc1ttZXRob2RdXG5cdH1cblx0Ly8gYXR0YWNoIFN0YXRlIHRyYW5zaXRpb25zIGZyb20gcGxhblxuXHRmb3IgKGNvbnN0IHN0YXRlIGluIHBsYW4uc3RhdGVzKSB7XG5cdFx0cHJvdG90eXBlW3N0YXRlXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVycyh0aGlzKVxuXHRcdFx0dGhpcy5zdGF0ZS5zZXQoc3RhdGUpXG5cdFx0XHRwbGFuLnN0YXRlc1tzdGF0ZV0uY2FsbCh0aGlzKVxuXHRcdH1cblx0fVxuXG5cdGlmIChwbGFuLnVwZGF0ZSkge1xuXHRcdHByb3RvdHlwZS51cGRhdGUgPSBwbGFuLnVwZGF0ZVxuXHR9XG5cblx0cHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHBsYW4uZGVzdHJveSkge1xuXHRcdFx0cGxhbi5kZXN0cm95LmNhbGwodGhpcylcblx0XHR9XG5cdH1cblxuXHRwcm90b3R5cGUuY29uc3RydWN0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG5cdFx0dGhpcy5wcm9wcyA9IHt9XG5cdFx0Zm9yIChjb25zdCBrIGluIHByb3BzKSB7XG5cdFx0XHRpZiAoayA9PT0gJ2tleScgfHwgayA9PT0gJ3JlZicgfHwgayA9PT0gJ3Byb3h5Jykge1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5wcm9wc1trXSA9IHByb3BzW2tdXG5cdFx0fVxuXHRcdC8vIHBhc3MgdGhlIHRyYW5zZm9ybSB2YWx1ZSB1cCB0byB0aGUgbm9kZVxuXHRcdHByb3BzLnRyYW5zZm9ybSA9IHBsYW4udHJhbnNmb3JtICE9PSBmYWxzZVxuXG5cdFx0Ly8gdGhlIGNhbm9uaWNhbCBkYXRhIG9iamVjdCB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBkYXRhXG5cdFx0Y29uc3QgZGF0YSA9IHt9XG5cblx0XHQvLyBzZXQgaW5pdGlhbCBwb3NpdGlvbmFsIHZhbHVlc1xuXHRcdE9iamVjdC5hc3NpZ24oZGF0YSwge1xuXHRcdFx0eDogcHJvcHMueCB8fCBwbGFuLnggfHwgMCxcblx0XHRcdHk6IHByb3BzLnkgfHwgcGxhbi55IHx8IDAsXG5cdFx0XHR3OiBwcm9wcy53IHx8IHBsYW4udyxcblx0XHRcdGg6IHByb3BzLmggfHwgcGxhbi5oLFxuXHRcdH0pXG5cblx0XHQvLyBwcm94eSBkYXRhIG9iamVjdCB3aG9zZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGFsbG93IGZvciBhdXRvbWF0aWMgcmVyZW5kZXJpbmdcblx0XHR0aGlzLmRhdGEgPSB7fVxuXG5cdFx0Ly8gZG8geCwgeSwgdywgYW5kIGggZmlyc3Qgc28gdGhleSdyZSBhdmFpbGFibGUgaW4gdGhlIHBsYW4uZGF0YSBmdW5jdGlvblxuXHRcdGZvciAoY29uc3QgayBpbiBkYXRhKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5kYXRhLCBrLCB7XG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0ICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YVtrXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6ICh2YWwpID0+IHtcblx0XHRcdFx0XHRkYXRhW2tdID0gdmFsXG5cdFx0XHRcdFx0dGhpcy5ub2RlLnNjaGVkdWxlUmVuZGVyKClcblx0XHRcdFx0fSxcblx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0Ly8gYWxsb3cgZm9yIG1vdmluZyB0aGUgY29tcG9uZW50IHdpdGhvdXQgcmVyZW5kZXJpbmcgaXRcblx0XHRmb3IgKGNvbnN0IGsgb2YgWyd4JywgJ3knXSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGssIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRnZXQgKCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhW2tdXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogKHZhbCkgPT4ge1xuXHRcdFx0XHRcdGlmICh2YWwgIT09IGRhdGFba10pIHtcblx0XHRcdFx0XHRcdGRhdGFba10gPSB2YWxcblx0XHRcdFx0XHRcdHRoaXMubm9kZS5zY2hlZHVsZU1vdmUoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdH0pXG5cdFx0fVxuXG5cblx0XHRpZiAocGxhbi5kYXRhKSB7XG5cdFx0XHRjb25zdCBwbGFuRGF0YSA9IHBsYW4uZGF0YS5jYWxsKHRoaXMpXG5cblx0XHRcdGZvciAoY29uc3QgayBpbiBwbGFuRGF0YSkge1xuXHRcdFx0XHRkYXRhW2tdID0gcGxhbkRhdGFba11cblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZGF0YSwgaywge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YVtrXVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c2V0OiAodmFsKSA9PiB7XG5cdFx0XHRcdFx0XHRkYXRhW2tdID0gdmFsXG5cdFx0XHRcdFx0XHR0aGlzLm5vZGUuc2NoZWR1bGVSZW5kZXIoKVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHByb3BzLnByb3h5KSB7XG5cdFx0XHRwcm9wcy5wcm94eSgocHJveGllZCwgLi4uYmluZGluZ3MpID0+IHtcblx0XHRcdFx0dGhpcy5wcm94eU9mID0gcHJveGllZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgYmluZGluZywge1xuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwcm94aWVkW2JpbmRpbmddXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0c2V0ICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcHJveGllZFtiaW5kaW5nXSA9IHZhbHVlXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXG5cdFx0Ly8gb2ggY29vbCwgYWN0dWFsbHkgdGhlIG9yZGVyIG9mIGV2ZW50cyBpczpcblx0XHQvLyAgLSBwYXJlbnQgY29tcG9uZW50IGNoYW5nZXMgc3RhdGVcblx0XHQvLyAgID4gc2NoZWR1bGVzIHJlcmVuZGVyXG5cdFx0Ly8gIC0gY2hpbGQgY29tcG9uZW50IGRvZXMgbm90IGhhdmUgTmV3U3RhdGUsIHNvIGl0IGNhbGxzIFJlYWR5IGluc3RlYWRcblx0XHQvLyAgLSByZXJlbmRlciBvY2N1cnMsIGNoaWxkIHJlY2VpdmVzIE5ld1N0YXRlXG5cdFx0Ly9cblx0XHQvLyAgc28gcHJvYmxlbS4uLiBhdmVydGVkIGZvciBub3dcblx0XHRsZXQgc3RhcnRTdGF0ZSA9ICdSZWFkeSdcblx0XHRpZiAocHJvcHMuc3RhdGUgJiYgdGhpc1twcm9wcy5zdGF0ZS5uYW1lXSkge1xuXHRcdFx0c3RhcnRTdGF0ZSA9IHByb3BzLnN0YXRlLm5hbWVcblx0XHR9XG5cblx0XHR0aGlzLnN0YXRlID0gbmV3IFN0YXRlKHN0YXJ0U3RhdGUsIHRoaXMpXG5cdH1cblxuXHRjb25zdCBjb25zdHJ1Y3RvciA9IHBsYW4uaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykgPyBwbGFuLmNvbnN0cnVjdG9yIDogZnVuY3Rpb24gQ29tcG9uZW50IChwcm9wcykge1xuXHRcdHRoaXMuY29uc3RydWN0KHByb3BzKVxuXHR9XG5cblx0aWYgKHBsYW4udHJhbnNmb3JtID09PSBmYWxzZSkge1xuXHRcdGNvbnN0cnVjdG9yLnRyYW5zZm9ybSA9IGZhbHNlXG5cdH1cblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlXG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yXG5cblx0cmV0dXJuIGNvbnN0cnVjdG9yXG59XG5cbkNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHtcblx0Ly8gbGlzdGVuIGZvciBhIGNlcnRhaW4gZXZ0eXBlLiBoYW5kbGVyIGlzIHJlbW92ZWQgdXBvbiBzdGF0ZSBjaGFuZ2Vcblx0b24gKGV2dHlwZSwgaGFuZGxlcikge1xuXHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIGV2dHlwZSwgaGFuZGxlcilcblx0fSxcblx0Ly8gbGlzdGVuIGZvciBhIGNlcnRhaW4gZXZ0eXBlLiBoYW5kbGVyIHBlcnNpc3RzIHRocm91Z2ggc3RhdGUgY2hhbmdlc1xuXHRsaXN0ZW4gKGV2dHlwZSwgaGFuZGxlcikge1xuXHRcdHRoaXMubm9kZS5hZGRQZXJzaXN0ZW50TGlzdGVuZXIodGhpcywgZXZ0eXBlLCBoYW5kbGVyKVxuXHR9LFxuXHQvLyByZW1vdmVzIGEgcGVyc2lzdGVudCBsaXN0ZW5lclxuXHR1bmxpc3RlbiAoZXZ0eXBlKSB7XG5cdFx0dGhpcy5ub2RlLnJlbW92ZVBlcnNpc3RlbnRMaXN0ZW5lcih0aGlzLCBldnR5cGUpXG5cdH0sXG5cdGdldENvbGxpc2lvbnMgKCkge1xuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0Q29sbGlzaW9ucyh0aGlzKVxuXHR9LFxuXHQvLyBzZXRzIG93biBzdGF0ZSB0byB0aGUgZ2l2ZW4gbmFtZSBhbmQgYXR0ZW1wdHMgdG8gY2FsbCB0aGF0IHN0YXRlIGZ1bmN0aW9uXG5cdHNldFN0YXRlIChuYW1lKSB7XG5cdFx0dGhpcy5zdGF0ZS5zZXQobmFtZSlcblx0XHRpZiAodGhpc1tuYW1lXSkge1xuXHRcdFx0dGhpc1tuYW1lXSgpXG5cdFx0fVxuXHRcdHRoaXMubm9kZS5zY2hlZHVsZVJlbmRlcigpXG5cdH0sXG5cdF9yZWNlaXZlUHJvcHMgKHByb3BzKSB7XG5cblx0XHRmb3IgKGNvbnN0IGsgb2YgWyd4JywgJ3knLCAndycsICdoJ10pIHtcblx0XHRcdGlmIChwcm9wc1trXSAhPT0gdW5kZWZpbmVkICYmIHByb3BzW2tdICE9PSB0aGlzLnByb3BzW2tdKSB7XG5cdFx0XHRcdC8vIGNhbGwgZ2V0dGVycyAvIHNldHRlcnMgdG8gYWN0IGFwcHJvcHJpYXRlbHlcblx0XHRcdFx0dGhpc1trXSA9IHByb3BzW2tdXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBwIGluIHByb3BzKSB7XG5cdFx0XHR0aGlzLnByb3BzW3BdID0gcHJvcHNbcF1cblx0XHR9XG5cdFx0Ly90aGlzLnByb3BzID0gcHJvcHNcblxuXHRcdC8vIGlmIHN0YXRlIGhhcyBjaGFuZ2VkLCBjYWxsIHRoZSBzdGF0ZSB0cmFuc2l0aW9uIGZ1bmN0aW9uXG5cdFx0aWYgKHByb3BzLnN0YXRlICYmIHByb3BzLnN0YXRlLmlzVXBkYXRlZCkge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZShwcm9wcy5zdGF0ZS5uYW1lKVxuXHRcdH1cblxuXHR9LFxufVxuXG4vLyBhdHRhY2ggdywgaCBjb252ZW5pZW5jZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4vLyB3IGFuZCBoIHNob3VsZCB0cmlnZ2VyIGEgcmVyZW5kZXJcbi8vIHRoZXNlIGFyZSBjb21tb24gYW1vbmcgYWxsIGNvbXBvbmVudHMgc28gd2UgYXR0YWNoIHRoZW0gdG8gQ29uc3RydWN0b3IucHJvdG90eXBlXG4vL1xuZm9yIChjb25zdCBrIG9mIFsndycsICdoJ10pIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLnByb3RvdHlwZSwgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhW2tdXG5cdFx0fSxcblx0XHRzZXQgKHZhbCkge1xuXHRcdFx0dGhpcy5kYXRhW2tdID0gdmFsXG5cdFx0XHRyZXR1cm4gdmFsXG5cdFx0fSxcblx0fSlcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZSAobmFtZSwgY29tcG9uZW50KSB7XG5cdHRoaXNbbmFtZV0gPSB0cnVlXG5cdHRoaXMubmFtZSA9IG5hbWVcblx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnRcblx0dGhpcy5zdGFjayA9IFtdXG59XG5cblN0YXRlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuXHR0aGlzW3RoaXMubmFtZV0gPSB1bmRlZmluZWRcblx0dGhpc1tuYW1lXSA9IHRydWVcblx0dGhpcy5uYW1lID0gbmFtZVxuXHR0aGlzLmlzVXBkYXRlZCA9IHRydWVcbn1cblxuU3RhdGUucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuc3RhY2sucHVzaCh0aGlzLm5hbWUpXG59XG5cblN0YXRlLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBuYW1lID0gdGhpcy5zdGFjay5wb3AoKVxuXHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUcmllZCB0byByZXN0b3JlIHN0YXRlIHdpdGggbm8gc3RhdGVzIG9uIHRoZSBzdGFjaycpXG5cdH1cblx0dGhpcy5jb21wb25lbnQuc2V0U3RhdGUobmFtZSlcbn1cblxuLy9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvclxuXG5leHBvcnQgZGVmYXVsdCBDb25zdHJ1Y3RvclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUEzQ0E7QUFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/constructor.js\n");

/***/ }),

/***/ "./src/lib/cute.js":
/*!*************************!*\
  !*** ./src/lib/cute.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primitives */ \"./src/lib/primitives.js\");\n/* harmony import */ var _constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructor */ \"./src/lib/constructor.js\");\n/* harmony import */ var _screen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./screen */ \"./src/lib/screen.js\");\n/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dispatch */ \"./src/lib/dispatch.js\");\n/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scheduler */ \"./src/lib/scheduler.js\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node */ \"./src/lib/node.js\");\n/* harmony import */ var _structures__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./structures */ \"./src/lib/structures.js\");\n\n\n\n\n\n\n\n\nconst Cute = (plan, ...wrappers) => {\n\treturn Object(_constructor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(plan, ...wrappers);\n};\n\nCute.canvas = document.createElement('canvas');\nCute.ctx = Cute.canvas.getContext('2d');\n\nCute.screen = new _screen__WEBPACK_IMPORTED_MODULE_2__[\"default\"](Cute.ctx);\nCute.dispatch = new _dispatch__WEBPACK_IMPORTED_MODULE_3__[\"default\"](Cute.canvas, Cute.screen);\nCute.scheduler = new _scheduler__WEBPACK_IMPORTED_MODULE_4__[\"default\"](Cute.screen);\nCute.structures = _structures__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n\nconst Node = Object(_node__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(Cute.screen, Cute.scheduler, Cute.dispatch);\n\nCute.attach = function (RootComponent, parentElement, canvasWidth, canvasHeight) {\n\tthis.canvas.width = canvasWidth;\n\tthis.canvas.height = canvasHeight;\n\tparentElement.appendChild(this.canvas);\n\tthis.canvas.setAttribute('tabindex', '0');\n\tthis.canvas.focus();\n\tthis.screen.setDimensions(canvasWidth, canvasHeight);\n\tthis.screen.setRootElement(RootComponent);\n};\n\nCute.createElement = function (type, props, ...children) {\n\t//console.log(type)\n\t//console.log(props)\n\t//console.log(children)\n\tif (typeof type === 'string') {\n\t\treturn new Node(_primitives__WEBPACK_IMPORTED_MODULE_0__[\"default\"]._lookup(type), props, children);\n\t}\n\treturn new Node(type, props, children);\n};\n\n// Allows you to directly reference a child component from a parent\n// component. Black magic sort of stuff. Generally you should avoid\n// making refs if you can, but alas, sometimes you cannot\nCute.createRef = function () {\n\treturn new Ref();\n};\n\nfunction Ref() {}\n\nRef.prototype.reference = function (component) {\n\tthis.component = component;\n};\n\nCute.store = {};\nCute.createStore = function (name, value) {\n\tthis.store[name] = value || {};\n};\n\nCute.Constructor = _constructor__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cute);\n\nwindow.Cute = Cute;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL2N1dGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9jdXRlLmpzPzhhMTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuaW1wb3J0IENvbnN0cnVjdG9yIGZyb20gJy4vY29uc3RydWN0b3InXG5pbXBvcnQgU2NyZWVuIGZyb20gJy4vc2NyZWVuJ1xuaW1wb3J0IERpc3BhdGNoIGZyb20gJy4vZGlzcGF0Y2gnXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJy4vc2NoZWR1bGVyJ1xuaW1wb3J0IE5vZGVDb250ZXh0IGZyb20gJy4vbm9kZSdcbmltcG9ydCBzdHJ1Y3R1cmVzIGZyb20gJy4vc3RydWN0dXJlcydcblxuY29uc3QgQ3V0ZSA9IChwbGFuLCAuLi53cmFwcGVycykgPT4ge1xuXHRyZXR1cm4gQ29uc3RydWN0b3IocGxhbiwgLi4ud3JhcHBlcnMpXG59XG5cbkN1dGUuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbkN1dGUuY3R4ID0gQ3V0ZS5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG5DdXRlLnNjcmVlbiA9IG5ldyBTY3JlZW4oQ3V0ZS5jdHgpXG5DdXRlLmRpc3BhdGNoID0gbmV3IERpc3BhdGNoKEN1dGUuY2FudmFzLCBDdXRlLnNjcmVlbilcbkN1dGUuc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcihDdXRlLnNjcmVlbilcbkN1dGUuc3RydWN0dXJlcyA9IHN0cnVjdHVyZXNcblxuY29uc3QgTm9kZSA9IE5vZGVDb250ZXh0KEN1dGUuc2NyZWVuLCBDdXRlLnNjaGVkdWxlciwgQ3V0ZS5kaXNwYXRjaClcblxuQ3V0ZS5hdHRhY2ggPSBmdW5jdGlvbiAoUm9vdENvbXBvbmVudCwgcGFyZW50RWxlbWVudCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCkge1xuXHR0aGlzLmNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoXG5cdHRoaXMuY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodFxuXHRwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKVxuXHR0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKVxuXHR0aGlzLmNhbnZhcy5mb2N1cygpXG5cdHRoaXMuc2NyZWVuLnNldERpbWVuc2lvbnMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodClcblx0dGhpcy5zY3JlZW4uc2V0Um9vdEVsZW1lbnQoUm9vdENvbXBvbmVudClcbn1cblxuQ3V0ZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCAuLi5jaGlsZHJlbikge1xuXHQvL2NvbnNvbGUubG9nKHR5cGUpXG5cdC8vY29uc29sZS5sb2cocHJvcHMpXG5cdC8vY29uc29sZS5sb2coY2hpbGRyZW4pXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gbmV3IE5vZGUocHJpbWl0aXZlcy5fbG9va3VwKHR5cGUpLCBwcm9wcywgY2hpbGRyZW4pXG5cdH1cblx0cmV0dXJuIG5ldyBOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbilcbn1cblxuLy8gQWxsb3dzIHlvdSB0byBkaXJlY3RseSByZWZlcmVuY2UgYSBjaGlsZCBjb21wb25lbnQgZnJvbSBhIHBhcmVudFxuLy8gY29tcG9uZW50LiBCbGFjayBtYWdpYyBzb3J0IG9mIHN0dWZmLiBHZW5lcmFsbHkgeW91IHNob3VsZCBhdm9pZFxuLy8gbWFraW5nIHJlZnMgaWYgeW91IGNhbiwgYnV0IGFsYXMsIHNvbWV0aW1lcyB5b3UgY2Fubm90XG5DdXRlLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBSZWYoKVxufVxuXG5mdW5jdGlvbiBSZWYgKCkge31cblxuUmVmLnByb3RvdHlwZS5yZWZlcmVuY2UgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG5cdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50XG59XG5cbkN1dGUuc3RvcmUgPSB7fVxuQ3V0ZS5jcmVhdGVTdG9yZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHR0aGlzLnN0b3JlW25hbWVdID0gdmFsdWUgfHwge31cbn1cblxuQ3V0ZS5Db25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yXG5cbmV4cG9ydCBkZWZhdWx0IEN1dGVcblxud2luZG93LkN1dGUgPSBDdXRlXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/cute.js\n");

/***/ }),

/***/ "./src/lib/dispatch.js":
/*!*****************************!*\
  !*** ./src/lib/dispatch.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction Dispatch(canvas, screen) {\n\t// the actual listener we attach to the canvas element. dispatches events\n\t// to the correct components\n\tfunction DispatchEventListener(evtype) {\n\t\treturn function (evt) {\n\t\t\tdispatch(evtype, evt);\n\t\t};\n\t}\n\n\t// all the event types to dispatch\n\tconst allEventTypes = ['blur', 'click', 'dblclick', 'focus', 'keydown', 'keypress', 'keyup', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'scroll', 'wheel'];\n\n\t// add actual event listeners to canvas\n\tallEventTypes.forEach(function (evtype) {\n\t\tcanvas.addEventListener(evtype, DispatchEventListener(evtype));\n\t});\n\n\t// listeners that reset on every state change\n\tconst ephemeralListeners = {\n\t\t// local mouse events, only fired when the mouse is over a component with highest z index\n\t\tlocal: new Map(),\n\t\t// local mouse events, only fired when the mouse is over any components\n\t\tmulti: new Map(),\n\t\t// global events, always fired for all components with handlers\n\t\tglobal: {}\n\n\t\t// listeners that persist through state changes\n\t};const persistentListeners = {\n\t\t// local mouse events, only fired when the mouse is over a component with highest z index\n\t\tlocal: new Map(),\n\t\t// local mouse events, only fired when the mouse is over any components\n\t\tmulti: new Map(),\n\t\t// global events, always fired for all components with handlers\n\t\tglobal: {}\n\n\t\t// set up global listener maps\n\t};allEventTypes.forEach(evtype => {\n\t\tephemeralListeners.global[evtype] = new Map();\n\t\tpersistentListeners.global[evtype] = new Map();\n\t});\n\n\t// keyboard events do not have clientX and clientY coordinates, so we'll keep track\n\t// of where the mouse is ourselves to dispatch local keyboard events\n\tlet canvasX = null;\n\tlet canvasY = null;\n\tcanvas.addEventListener('mousemove', evt => {\n\t\tcanvas.focus();\n\t\taddCanvasCoords(evt);\n\t\tcanvasX = evt.canvasX;\n\t\tcanvasY = evt.canvasY;\n\t});\n\n\t// get the coordinates of the mouse with respect to the canvas\n\t// TODO: deal with scale / rotation\n\tfunction addCanvasCoords(evt) {\n\t\tif (!evt.clientX) {\n\t\t\t// non-mouse events will not have coordinates\n\t\t\tevt.canvasX = canvasX;\n\t\t\tevt.canvasY = canvasY;\n\t\t\treturn;\n\t\t}\n\t\tconst rect = canvas.getBoundingClientRect();\n\t\tevt.canvasX = evt.clientX - rect.left;\n\t\tevt.canvasY = evt.clientY - rect.top;\n\t}\n\n\t// get the coordinates of the mouse with respect to a component\n\tfunction addLocalCoords(component, evt) {\n\t\tevt.localX = evt.canvasX - component.node.screenX;\n\t\tevt.localY = evt.canvasY - component.node.screenY;\n\t}\n\n\t// dispatches event to specified map. map might be 'local' or 'multi'\n\tfunction dispatchToMap(map, component, evtype, evt) {\n\t\taddLocalCoords(component, evt);\n\t\tfor (const listeners of [ephemeralListeners, persistentListeners]) {\n\t\t\tconst handlers = listeners[map].get(component);\n\t\t\tif (handlers && handlers[evtype]) {\n\t\t\t\thandlers[evtype].call(component, evt);\n\t\t\t}\n\t\t}\n\t}\n\n\t// dispatches local events to ephemeral and persistent local listeners\n\tfunction dispatchLocal(component, evtype, evt) {\n\t\tif (!component) {\n\t\t\treturn;\n\t\t}\n\t\tevt.component = component;\n\t\tdispatchToMap('local', component, evtype, evt);\n\t}\n\n\t// dispatches events to ephemeral and persistent multi listeners\n\tfunction dispatchMulti(components, evtype, evt) {\n\t\tcomponents.forEach(component => {\n\t\t\t// this will fail for any asynchronous multi event handler, but events are massive and I don't want to copy the whole thing\n\t\t\tevt.component = component;\n\t\t\tdispatchToMap('multi', component, evtype, evt);\n\t\t});\n\t}\n\n\t// dispatches events to either ephemeral or persistent global listeners\n\tfunction dispatchGlobal(listeners, evtype, evt) {\n\t\tlisteners.global[evtype].forEach((handler, component) => {\n\t\t\taddLocalCoords(component, evt);\n\t\t\thandler.call(component, evt);\n\t\t});\n\t}\n\n\t// mouseover, mouseout, mouseenter, and mouseleaves all require special handling\n\t// we do it here\n\tlet mousePrior = null;\n\tlet mousePriorAll = [];\n\n\tfunction dispatchMouseoverMouseout(evtype, evt) {\n\t\tconst mouseOn = screen.queryPoint(evt.canvasX, evt.canvasY);\n\t\tconst mouseOver = screen.queryPointAll(evt.canvasX, evt.canvasY);\n\t\tif (evtype === 'mousemove') {\n\t\t\tif (mouseOn !== mousePrior) {\n\t\t\t\tif (mouseOn !== null) {\n\t\t\t\t\tdispatchLocal(mouseOn, 'mouseover', evt);\n\t\t\t\t}\n\t\t\t\tif (mousePrior !== null) {\n\t\t\t\t\tdispatchLocal(mousePrior, 'mouseout', evt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmouseOver.forEach(component => {\n\t\t\t\tif (!mousePriorAll.includes(component)) {\n\t\t\t\t\tdispatchLocal(component, 'mouseenter', evt);\n\t\t\t\t}\n\t\t\t});\n\t\t\tmousePriorAll.forEach(component => {\n\t\t\t\tif (!mouseOver.includes(component)) {\n\t\t\t\t\tdispatchLocal(component, 'mouseleave', evt);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (evtype === 'mouseout') {\n\t\t\tif (mousePrior !== null) {\n\t\t\t\tdispatchLocal(mousePrior, 'mouseout', evt);\n\t\t\t}\n\t\t\tmousePriorAll.forEach(prior => {\n\t\t\t\tdispatchLocal(prior, 'mouseleave', evt);\n\t\t\t});\n\t\t}\n\t\tmousePrior = mouseOn;\n\t\tmousePriorAll = mouseOver;\n\t}\n\n\t// returns whether a compnent has a listener for a given evtype\n\tfunction hasLocalListener(component, evtype) {\n\t\tfor (const listeners of [persistentListeners, ephemeralListeners]) {\n\t\t\tconst handlers = listeners.local.get(component);\n\t\t\tif (handlers && handlers[evtype]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// the function called when any event is sent to the canvas. determines\n\t// canvas coordinates, then calls all appropriate handlers\n\tfunction dispatch(evtype, evt) {\n\t\t// get canvas coordinates of evt\n\t\taddCanvasCoords(evt);\n\t\t// dispatch event to global handlers\n\t\tdispatchGlobal(ephemeralListeners, evtype, evt);\n\t\tdispatchGlobal(persistentListeners, evtype, evt);\n\t\t// dispatch event to multi handlers\n\t\tconst allComponents = screen.queryPointAll(evt.canvasX, evt.canvasY);\n\t\tdispatchMulti(allComponents, evtype, evt);\n\t\t// get topmost component with a handler for the given evtype\n\t\tconst component = allComponents.find(comp => hasLocalListener(comp, evtype));\n\t\t// dispatch event to local handlers\n\t\tdispatchLocal(component, evtype, evt);\n\t\t// dispatch mouseover, mouseout, mouseenter, and mouseleave events\n\t\tdispatchMouseoverMouseout(evtype, evt);\n\t}\n\n\t// attempts to extract an evtype from an evtype of form <evtype>G\n\t// if it is not a global evtype, returns undefined\n\tfunction extractGlobalEvtype(evtype) {\n\t\tif (evtype[evtype.length - 1] === 'G') {\n\t\t\treturn evtype.substring(0, evtype.length - 1);\n\t\t}\n\t}\n\n\t// attempts to extract an evtype from an evtype of form <evtype>M\n\t// if it is not a multi evtype, returns undefined\n\tfunction extractMultiEvtype(evtype) {\n\t\tif (evtype[evtype.length - 1] === 'M') {\n\t\t\treturn evtype.substring(0, evtype.length - 1);\n\t\t}\n\t}\n\n\t// adds the listener to the specified map. this might be a persistent,\n\t// ephemeral, local, or multi listener\n\tfunction addListenerToMap(map, component, evtype, handler) {\n\t\tif (map.has(component)) {\n\t\t\tmap.get(component)[evtype] = handler;\n\t\t} else {\n\t\t\tconst handlers = {};\n\t\t\thandlers[evtype] = handler;\n\t\t\tmap.set(component, handlers);\n\t\t}\n\t}\n\n\t// adds a listener to ephemeral or persistent listener containers\n\tfunction addListener(listeners, component, evtype, handler) {\n\t\tconst globalEvtype = extractGlobalEvtype(evtype);\n\t\tif (globalEvtype !== undefined) {\n\t\t\treturn listeners.global[globalEvtype].set(component, handler);\n\t\t}\n\t\tconst multiEvtype = extractMultiEvtype(evtype);\n\t\tif (multiEvtype !== undefined) {\n\t\t\treturn addListenerToMap(listeners.multi, component, evtype, handler);\n\t\t}\n\t\taddListenerToMap(listeners.local, component, evtype, handler);\n\t}\n\n\t// adds an ephemeral listener\n\tthis.addEventListener = function (component, evtype, handler) {\n\t\taddListener(ephemeralListeners, component, evtype, handler);\n\t};\n\n\t// adds a persistent listener\n\tthis.addPersistentListener = function (component, evtype, handler) {\n\t\taddListener(persistentListeners, component, evtype, handler);\n\t};\n\n\t// helper function that removes a listener from either ephemeral or persistent listeners\n\tfunction removeListener(listeners, component, evtype) {\n\t\tconst globalEvtype = extractGlobalEvtype(evtype);\n\t\tif (globalEvtype !== undefined) {\n\t\t\treturn listeners.global[globalEvtype].delete(component);\n\t\t}\n\t\t// we determine whether to remove a local or multi listener\n\t\tlet map = listeners.local;\n\t\tlet targetEvtype = evtype;\n\t\tconst multiEvtype = extractMultiEvtype(evtype);\n\t\tif (multiEvtype !== undefined) {\n\t\t\tmap = listeners.multi;\n\t\t\ttargetEvtype = multiEvtype;\n\t\t}\n\t\t// and then remove it here\n\t\tmap.get(component)[targetEvtype] = undefined;\n\t}\n\n\t// public method for removing a listener\n\tthis.removeEventListener = function (component, evtype) {\n\t\tremoveListener(ephemeralListeners, component, evtype);\n\t};\n\n\t// public method for removing a persistent listener\n\tthis.removePersistentListener = function (component, evtype) {\n\t\tremoveListener(persistentListeners, component, evtype);\n\t};\n\n\t// helper functino that removes all listeners from either ephemeral or persistent listeners\n\tfunction removeListeners(listeners, component) {\n\t\tlisteners.local.delete(component);\n\t\tlisteners.multi.delete(component);\n\t\tfor (const evtype in listeners.global) {\n\t\t\tlisteners.global[evtype].delete(component);\n\t\t}\n\t}\n\n\t// public method for removing all event listeners\n\tthis.removeEventListeners = function (component) {\n\t\tremoveListeners(ephemeralListeners, component);\n\t};\n\n\t// public method for removing all persistent listeners\n\tthis.removePersistentListeners = function (component) {\n\t\tremoveListeners(persistentListeners, component);\n\t};\n\n\tthis.removeComponent = function (component) {\n\t\tthis.removeEventListeners(component);\n\t\tthis.removePersistentListeners(component);\n\t};\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dispatch);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL2Rpc3BhdGNoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9saWIvZGlzcGF0Y2guanM/NTk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBEaXNwYXRjaCAoY2FudmFzLCBzY3JlZW4pIHtcblx0Ly8gdGhlIGFjdHVhbCBsaXN0ZW5lciB3ZSBhdHRhY2ggdG8gdGhlIGNhbnZhcyBlbGVtZW50LiBkaXNwYXRjaGVzIGV2ZW50c1xuXHQvLyB0byB0aGUgY29ycmVjdCBjb21wb25lbnRzXG5cdGZ1bmN0aW9uIERpc3BhdGNoRXZlbnRMaXN0ZW5lciAoZXZ0eXBlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcblx0XHRcdGRpc3BhdGNoKGV2dHlwZSwgZXZ0KVxuXHRcdH1cblx0fVxuXG5cdC8vIGFsbCB0aGUgZXZlbnQgdHlwZXMgdG8gZGlzcGF0Y2hcblx0Y29uc3QgYWxsRXZlbnRUeXBlcyA9IFtcblx0XHQnYmx1cicsXG5cdFx0J2NsaWNrJyxcblx0XHQnZGJsY2xpY2snLFxuXHRcdCdmb2N1cycsXG5cdFx0J2tleWRvd24nLFxuXHRcdCdrZXlwcmVzcycsXG5cdFx0J2tleXVwJyxcblx0XHQnbW91c2Vkb3duJyxcblx0XHQnbW91c2VlbnRlcicsXG5cdFx0J21vdXNlbGVhdmUnLFxuXHRcdCdtb3VzZW1vdmUnLFxuXHRcdCdtb3VzZW91dCcsXG5cdFx0J21vdXNlb3ZlcicsXG5cdFx0J21vdXNldXAnLFxuXHRcdCdzY3JvbGwnLFxuXHRcdCd3aGVlbCcsXG5cdF1cblxuXHQvLyBhZGQgYWN0dWFsIGV2ZW50IGxpc3RlbmVycyB0byBjYW52YXNcblx0YWxsRXZlbnRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChldnR5cGUpIHtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihldnR5cGUsIERpc3BhdGNoRXZlbnRMaXN0ZW5lcihldnR5cGUpKVxuXHR9KVxuXG5cdC8vIGxpc3RlbmVycyB0aGF0IHJlc2V0IG9uIGV2ZXJ5IHN0YXRlIGNoYW5nZVxuXHRjb25zdCBlcGhlbWVyYWxMaXN0ZW5lcnMgPSB7XG5cdFx0Ly8gbG9jYWwgbW91c2UgZXZlbnRzLCBvbmx5IGZpcmVkIHdoZW4gdGhlIG1vdXNlIGlzIG92ZXIgYSBjb21wb25lbnQgd2l0aCBoaWdoZXN0IHogaW5kZXhcblx0XHRsb2NhbDogbmV3IE1hcCgpLFxuXHRcdC8vIGxvY2FsIG1vdXNlIGV2ZW50cywgb25seSBmaXJlZCB3aGVuIHRoZSBtb3VzZSBpcyBvdmVyIGFueSBjb21wb25lbnRzXG5cdFx0bXVsdGk6IG5ldyBNYXAoKSxcblx0XHQvLyBnbG9iYWwgZXZlbnRzLCBhbHdheXMgZmlyZWQgZm9yIGFsbCBjb21wb25lbnRzIHdpdGggaGFuZGxlcnNcblx0XHRnbG9iYWw6IHt9LFxuXHR9XG5cblx0Ly8gbGlzdGVuZXJzIHRoYXQgcGVyc2lzdCB0aHJvdWdoIHN0YXRlIGNoYW5nZXNcblx0Y29uc3QgcGVyc2lzdGVudExpc3RlbmVycyA9IHtcblx0XHQvLyBsb2NhbCBtb3VzZSBldmVudHMsIG9ubHkgZmlyZWQgd2hlbiB0aGUgbW91c2UgaXMgb3ZlciBhIGNvbXBvbmVudCB3aXRoIGhpZ2hlc3QgeiBpbmRleFxuXHRcdGxvY2FsOiBuZXcgTWFwKCksXG5cdFx0Ly8gbG9jYWwgbW91c2UgZXZlbnRzLCBvbmx5IGZpcmVkIHdoZW4gdGhlIG1vdXNlIGlzIG92ZXIgYW55IGNvbXBvbmVudHNcblx0XHRtdWx0aTogbmV3IE1hcCgpLFxuXHRcdC8vIGdsb2JhbCBldmVudHMsIGFsd2F5cyBmaXJlZCBmb3IgYWxsIGNvbXBvbmVudHMgd2l0aCBoYW5kbGVyc1xuXHRcdGdsb2JhbDoge30sXG5cdH1cblxuXHQvLyBzZXQgdXAgZ2xvYmFsIGxpc3RlbmVyIG1hcHNcblx0YWxsRXZlbnRUeXBlcy5mb3JFYWNoKGV2dHlwZSA9PiB7XG5cdFx0ZXBoZW1lcmFsTGlzdGVuZXJzLmdsb2JhbFtldnR5cGVdID0gbmV3IE1hcCgpXG5cdFx0cGVyc2lzdGVudExpc3RlbmVycy5nbG9iYWxbZXZ0eXBlXSA9IG5ldyBNYXAoKVxuXHR9KVxuXG5cdC8vIGtleWJvYXJkIGV2ZW50cyBkbyBub3QgaGF2ZSBjbGllbnRYIGFuZCBjbGllbnRZIGNvb3JkaW5hdGVzLCBzbyB3ZSdsbCBrZWVwIHRyYWNrXG5cdC8vIG9mIHdoZXJlIHRoZSBtb3VzZSBpcyBvdXJzZWx2ZXMgdG8gZGlzcGF0Y2ggbG9jYWwga2V5Ym9hcmQgZXZlbnRzXG5cdGxldCBjYW52YXNYID0gbnVsbFxuXHRsZXQgY2FudmFzWSA9IG51bGxcblx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGV2dCA9PiB7XG5cdFx0Y2FudmFzLmZvY3VzKClcblx0XHRhZGRDYW52YXNDb29yZHMoZXZ0KVxuXHRcdGNhbnZhc1ggPSBldnQuY2FudmFzWFxuXHRcdGNhbnZhc1kgPSBldnQuY2FudmFzWVxuXHR9KVxuXG5cdC8vIGdldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlIHdpdGggcmVzcGVjdCB0byB0aGUgY2FudmFzXG5cdC8vIFRPRE86IGRlYWwgd2l0aCBzY2FsZSAvIHJvdGF0aW9uXG5cdGZ1bmN0aW9uIGFkZENhbnZhc0Nvb3JkcyAoZXZ0KSB7XG5cdFx0aWYgKCFldnQuY2xpZW50WCkge1xuXHRcdFx0Ly8gbm9uLW1vdXNlIGV2ZW50cyB3aWxsIG5vdCBoYXZlIGNvb3JkaW5hdGVzXG5cdFx0XHRldnQuY2FudmFzWCA9IGNhbnZhc1hcblx0XHRcdGV2dC5jYW52YXNZID0gY2FudmFzWVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0XHRldnQuY2FudmFzWCA9IGV2dC5jbGllbnRYIC0gcmVjdC5sZWZ0XG5cdFx0ZXZ0LmNhbnZhc1kgPSBldnQuY2xpZW50WSAtIHJlY3QudG9wXG5cdH1cblxuXHQvLyBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZSB3aXRoIHJlc3BlY3QgdG8gYSBjb21wb25lbnRcblx0ZnVuY3Rpb24gYWRkTG9jYWxDb29yZHMgKGNvbXBvbmVudCwgZXZ0KSB7XG5cdFx0ZXZ0LmxvY2FsWCA9IGV2dC5jYW52YXNYIC0gY29tcG9uZW50Lm5vZGUuc2NyZWVuWFxuXHRcdGV2dC5sb2NhbFkgPSBldnQuY2FudmFzWSAtIGNvbXBvbmVudC5ub2RlLnNjcmVlbllcblx0fVxuXG5cdC8vIGRpc3BhdGNoZXMgZXZlbnQgdG8gc3BlY2lmaWVkIG1hcC4gbWFwIG1pZ2h0IGJlICdsb2NhbCcgb3IgJ211bHRpJ1xuXHRmdW5jdGlvbiBkaXNwYXRjaFRvTWFwIChtYXAsIGNvbXBvbmVudCwgZXZ0eXBlLCBldnQpIHtcblx0XHRhZGRMb2NhbENvb3Jkcyhjb21wb25lbnQsIGV2dClcblx0XHRmb3IgKGNvbnN0IGxpc3RlbmVycyBvZiBbZXBoZW1lcmFsTGlzdGVuZXJzLCBwZXJzaXN0ZW50TGlzdGVuZXJzXSkge1xuXHRcdFx0Y29uc3QgaGFuZGxlcnMgPSBsaXN0ZW5lcnNbbWFwXS5nZXQoY29tcG9uZW50KVxuXHRcdFx0aWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzW2V2dHlwZV0pIHtcblx0XHRcdFx0aGFuZGxlcnNbZXZ0eXBlXS5jYWxsKGNvbXBvbmVudCwgZXZ0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIGRpc3BhdGNoZXMgbG9jYWwgZXZlbnRzIHRvIGVwaGVtZXJhbCBhbmQgcGVyc2lzdGVudCBsb2NhbCBsaXN0ZW5lcnNcblx0ZnVuY3Rpb24gZGlzcGF0Y2hMb2NhbCAoY29tcG9uZW50LCBldnR5cGUsIGV2dCkge1xuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0ZXZ0LmNvbXBvbmVudCA9IGNvbXBvbmVudFxuXHRcdGRpc3BhdGNoVG9NYXAoJ2xvY2FsJywgY29tcG9uZW50LCBldnR5cGUsIGV2dClcblx0fVxuXG5cdC8vIGRpc3BhdGNoZXMgZXZlbnRzIHRvIGVwaGVtZXJhbCBhbmQgcGVyc2lzdGVudCBtdWx0aSBsaXN0ZW5lcnNcblx0ZnVuY3Rpb24gZGlzcGF0Y2hNdWx0aSAoY29tcG9uZW50cywgZXZ0eXBlLCBldnQpIHtcblx0XHRjb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IHtcblx0XHRcdC8vIHRoaXMgd2lsbCBmYWlsIGZvciBhbnkgYXN5bmNocm9ub3VzIG11bHRpIGV2ZW50IGhhbmRsZXIsIGJ1dCBldmVudHMgYXJlIG1hc3NpdmUgYW5kIEkgZG9uJ3Qgd2FudCB0byBjb3B5IHRoZSB3aG9sZSB0aGluZ1xuXHRcdFx0ZXZ0LmNvbXBvbmVudCA9IGNvbXBvbmVudFxuXHRcdFx0ZGlzcGF0Y2hUb01hcCgnbXVsdGknLCBjb21wb25lbnQsIGV2dHlwZSwgZXZ0KVxuXHRcdH0pXG5cdH1cblxuXHQvLyBkaXNwYXRjaGVzIGV2ZW50cyB0byBlaXRoZXIgZXBoZW1lcmFsIG9yIHBlcnNpc3RlbnQgZ2xvYmFsIGxpc3RlbmVyc1xuXHRmdW5jdGlvbiBkaXNwYXRjaEdsb2JhbCAobGlzdGVuZXJzLCBldnR5cGUsIGV2dCkge1xuXHRcdGxpc3RlbmVycy5nbG9iYWxbZXZ0eXBlXS5mb3JFYWNoKChoYW5kbGVyLCBjb21wb25lbnQpID0+IHtcblx0XHRcdGFkZExvY2FsQ29vcmRzKGNvbXBvbmVudCwgZXZ0KVxuXHRcdFx0aGFuZGxlci5jYWxsKGNvbXBvbmVudCwgZXZ0KVxuXHRcdH0pXG5cdH1cblxuXHQvLyBtb3VzZW92ZXIsIG1vdXNlb3V0LCBtb3VzZWVudGVyLCBhbmQgbW91c2VsZWF2ZXMgYWxsIHJlcXVpcmUgc3BlY2lhbCBoYW5kbGluZ1xuXHQvLyB3ZSBkbyBpdCBoZXJlXG5cdGxldCBtb3VzZVByaW9yID0gbnVsbFxuXHRsZXQgbW91c2VQcmlvckFsbCA9IFtdXG5cblx0ZnVuY3Rpb24gZGlzcGF0Y2hNb3VzZW92ZXJNb3VzZW91dCAoZXZ0eXBlLCBldnQpIHtcblx0XHRjb25zdCBtb3VzZU9uID0gc2NyZWVuLnF1ZXJ5UG9pbnQoZXZ0LmNhbnZhc1gsIGV2dC5jYW52YXNZKVxuXHRcdGNvbnN0IG1vdXNlT3ZlciA9IHNjcmVlbi5xdWVyeVBvaW50QWxsKGV2dC5jYW52YXNYLCBldnQuY2FudmFzWSlcblx0XHRpZiAoZXZ0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0aWYgKG1vdXNlT24gIT09IG1vdXNlUHJpb3IpIHtcblx0XHRcdFx0aWYgKG1vdXNlT24gIT09IG51bGwpIHtcblx0XHRcdFx0XHRkaXNwYXRjaExvY2FsKG1vdXNlT24sICdtb3VzZW92ZXInLCBldnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG1vdXNlUHJpb3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRkaXNwYXRjaExvY2FsKG1vdXNlUHJpb3IsICdtb3VzZW91dCcsIGV2dClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bW91c2VPdmVyLmZvckVhY2goY29tcG9uZW50ID0+IHtcblx0XHRcdFx0aWYgKCFtb3VzZVByaW9yQWxsLmluY2x1ZGVzKGNvbXBvbmVudCkpIHtcblx0XHRcdFx0XHRkaXNwYXRjaExvY2FsKGNvbXBvbmVudCwgJ21vdXNlZW50ZXInLCBldnQpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHRtb3VzZVByaW9yQWxsLmZvckVhY2goY29tcG9uZW50ID0+IHtcblx0XHRcdFx0aWYgKCFtb3VzZU92ZXIuaW5jbHVkZXMoY29tcG9uZW50KSkge1xuXHRcdFx0XHRcdGRpc3BhdGNoTG9jYWwoY29tcG9uZW50LCAnbW91c2VsZWF2ZScsIGV2dClcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0aWYgKGV2dHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuXHRcdFx0aWYgKG1vdXNlUHJpb3IgIT09IG51bGwpIHtcblx0XHRcdFx0ZGlzcGF0Y2hMb2NhbChtb3VzZVByaW9yLCAnbW91c2VvdXQnLCBldnQpXG5cdFx0XHR9XG5cdFx0XHRtb3VzZVByaW9yQWxsLmZvckVhY2gocHJpb3IgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaExvY2FsKHByaW9yLCAnbW91c2VsZWF2ZScsIGV2dClcblx0XHRcdH0pXG5cdFx0fVxuXHRcdG1vdXNlUHJpb3IgPSBtb3VzZU9uXG5cdFx0bW91c2VQcmlvckFsbCA9IG1vdXNlT3ZlclxuXHR9XG5cblx0Ly8gcmV0dXJucyB3aGV0aGVyIGEgY29tcG5lbnQgaGFzIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZ0eXBlXG5cdGZ1bmN0aW9uIGhhc0xvY2FsTGlzdGVuZXIgKGNvbXBvbmVudCwgZXZ0eXBlKSB7XG5cdFx0Zm9yIChjb25zdCBsaXN0ZW5lcnMgb2YgW3BlcnNpc3RlbnRMaXN0ZW5lcnMsIGVwaGVtZXJhbExpc3RlbmVyc10pIHtcblx0XHRcdGNvbnN0IGhhbmRsZXJzID0gbGlzdGVuZXJzLmxvY2FsLmdldChjb21wb25lbnQpXG5cdFx0XHRpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnNbZXZ0eXBlXSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdC8vIHRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBhbnkgZXZlbnQgaXMgc2VudCB0byB0aGUgY2FudmFzLiBkZXRlcm1pbmVzXG5cdC8vIGNhbnZhcyBjb29yZGluYXRlcywgdGhlbiBjYWxscyBhbGwgYXBwcm9wcmlhdGUgaGFuZGxlcnNcblx0ZnVuY3Rpb24gZGlzcGF0Y2ggKGV2dHlwZSwgZXZ0KSB7XG5cdFx0Ly8gZ2V0IGNhbnZhcyBjb29yZGluYXRlcyBvZiBldnRcblx0XHRhZGRDYW52YXNDb29yZHMoZXZ0KVxuXHRcdC8vIGRpc3BhdGNoIGV2ZW50IHRvIGdsb2JhbCBoYW5kbGVyc1xuXHRcdGRpc3BhdGNoR2xvYmFsKGVwaGVtZXJhbExpc3RlbmVycywgZXZ0eXBlLCBldnQpXG5cdFx0ZGlzcGF0Y2hHbG9iYWwocGVyc2lzdGVudExpc3RlbmVycywgZXZ0eXBlLCBldnQpXG5cdFx0Ly8gZGlzcGF0Y2ggZXZlbnQgdG8gbXVsdGkgaGFuZGxlcnNcblx0XHRjb25zdCBhbGxDb21wb25lbnRzID0gc2NyZWVuLnF1ZXJ5UG9pbnRBbGwoZXZ0LmNhbnZhc1gsIGV2dC5jYW52YXNZKVxuXHRcdGRpc3BhdGNoTXVsdGkoYWxsQ29tcG9uZW50cywgZXZ0eXBlLCBldnQpXG5cdFx0Ly8gZ2V0IHRvcG1vc3QgY29tcG9uZW50IHdpdGggYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gZXZ0eXBlXG5cdFx0Y29uc3QgY29tcG9uZW50ID0gYWxsQ29tcG9uZW50cy5maW5kKGNvbXAgPT4gaGFzTG9jYWxMaXN0ZW5lcihjb21wLCBldnR5cGUpKVxuXHRcdC8vIGRpc3BhdGNoIGV2ZW50IHRvIGxvY2FsIGhhbmRsZXJzXG5cdFx0ZGlzcGF0Y2hMb2NhbChjb21wb25lbnQsIGV2dHlwZSwgZXZ0KVxuXHRcdC8vIGRpc3BhdGNoIG1vdXNlb3ZlciwgbW91c2VvdXQsIG1vdXNlZW50ZXIsIGFuZCBtb3VzZWxlYXZlIGV2ZW50c1xuXHRcdGRpc3BhdGNoTW91c2VvdmVyTW91c2VvdXQoZXZ0eXBlLCBldnQpXG5cdH1cblxuXHQvLyBhdHRlbXB0cyB0byBleHRyYWN0IGFuIGV2dHlwZSBmcm9tIGFuIGV2dHlwZSBvZiBmb3JtIDxldnR5cGU+R1xuXHQvLyBpZiBpdCBpcyBub3QgYSBnbG9iYWwgZXZ0eXBlLCByZXR1cm5zIHVuZGVmaW5lZFxuXHRmdW5jdGlvbiBleHRyYWN0R2xvYmFsRXZ0eXBlIChldnR5cGUpIHtcblx0XHRpZiAoZXZ0eXBlW2V2dHlwZS5sZW5ndGggLSAxXSA9PT0gJ0cnKSB7XG5cdFx0XHRyZXR1cm4gZXZ0eXBlLnN1YnN0cmluZygwLCBldnR5cGUubGVuZ3RoIC0gMSlcblx0XHR9XG5cdH1cblxuXHQvLyBhdHRlbXB0cyB0byBleHRyYWN0IGFuIGV2dHlwZSBmcm9tIGFuIGV2dHlwZSBvZiBmb3JtIDxldnR5cGU+TVxuXHQvLyBpZiBpdCBpcyBub3QgYSBtdWx0aSBldnR5cGUsIHJldHVybnMgdW5kZWZpbmVkXG5cdGZ1bmN0aW9uIGV4dHJhY3RNdWx0aUV2dHlwZSAoZXZ0eXBlKSB7XG5cdFx0aWYgKGV2dHlwZVtldnR5cGUubGVuZ3RoIC0gMV0gPT09ICdNJykge1xuXHRcdFx0cmV0dXJuIGV2dHlwZS5zdWJzdHJpbmcoMCwgZXZ0eXBlLmxlbmd0aCAtIDEpXG5cdFx0fVxuXHR9XG5cblx0Ly8gYWRkcyB0aGUgbGlzdGVuZXIgdG8gdGhlIHNwZWNpZmllZCBtYXAuIHRoaXMgbWlnaHQgYmUgYSBwZXJzaXN0ZW50LFxuXHQvLyBlcGhlbWVyYWwsIGxvY2FsLCBvciBtdWx0aSBsaXN0ZW5lclxuXHRmdW5jdGlvbiBhZGRMaXN0ZW5lclRvTWFwIChtYXAsIGNvbXBvbmVudCwgZXZ0eXBlLCBoYW5kbGVyKSB7XG5cdFx0aWYgKG1hcC5oYXMoY29tcG9uZW50KSkge1xuXHRcdFx0bWFwLmdldChjb21wb25lbnQpW2V2dHlwZV0gPSBoYW5kbGVyXG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGhhbmRsZXJzID0ge31cblx0XHRcdGhhbmRsZXJzW2V2dHlwZV0gPSBoYW5kbGVyXG5cdFx0XHRtYXAuc2V0KGNvbXBvbmVudCwgaGFuZGxlcnMpXG5cdFx0fVxuXHR9XG5cblx0Ly8gYWRkcyBhIGxpc3RlbmVyIHRvIGVwaGVtZXJhbCBvciBwZXJzaXN0ZW50IGxpc3RlbmVyIGNvbnRhaW5lcnNcblx0ZnVuY3Rpb24gYWRkTGlzdGVuZXIgKGxpc3RlbmVycywgY29tcG9uZW50LCBldnR5cGUsIGhhbmRsZXIpIHtcblx0XHRjb25zdCBnbG9iYWxFdnR5cGUgPSBleHRyYWN0R2xvYmFsRXZ0eXBlKGV2dHlwZSlcblx0XHRpZiAoZ2xvYmFsRXZ0eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBsaXN0ZW5lcnMuZ2xvYmFsW2dsb2JhbEV2dHlwZV0uc2V0KGNvbXBvbmVudCwgaGFuZGxlcilcblx0XHR9XG5cdFx0Y29uc3QgbXVsdGlFdnR5cGUgPSBleHRyYWN0TXVsdGlFdnR5cGUoZXZ0eXBlKVxuXHRcdGlmIChtdWx0aUV2dHlwZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gYWRkTGlzdGVuZXJUb01hcChsaXN0ZW5lcnMubXVsdGksIGNvbXBvbmVudCwgZXZ0eXBlLCBoYW5kbGVyKVxuXHRcdH1cblx0XHRhZGRMaXN0ZW5lclRvTWFwKGxpc3RlbmVycy5sb2NhbCwgY29tcG9uZW50LCBldnR5cGUsIGhhbmRsZXIpXG5cdH1cblxuXHQvLyBhZGRzIGFuIGVwaGVtZXJhbCBsaXN0ZW5lclxuXHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBldnR5cGUsIGhhbmRsZXIpIHtcblx0XHRhZGRMaXN0ZW5lcihlcGhlbWVyYWxMaXN0ZW5lcnMsIGNvbXBvbmVudCwgZXZ0eXBlLCBoYW5kbGVyKVxuXHR9XG5cblx0Ly8gYWRkcyBhIHBlcnNpc3RlbnQgbGlzdGVuZXJcblx0dGhpcy5hZGRQZXJzaXN0ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBldnR5cGUsIGhhbmRsZXIpIHtcblx0XHRhZGRMaXN0ZW5lcihwZXJzaXN0ZW50TGlzdGVuZXJzLCBjb21wb25lbnQsIGV2dHlwZSwgaGFuZGxlcilcblx0fVxuXG5cdC8vIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgYSBsaXN0ZW5lciBmcm9tIGVpdGhlciBlcGhlbWVyYWwgb3IgcGVyc2lzdGVudCBsaXN0ZW5lcnNcblx0ZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIgKGxpc3RlbmVycywgY29tcG9uZW50LCBldnR5cGUpIHtcblx0XHRjb25zdCBnbG9iYWxFdnR5cGUgPSBleHRyYWN0R2xvYmFsRXZ0eXBlKGV2dHlwZSlcblx0XHRpZiAoZ2xvYmFsRXZ0eXBlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBsaXN0ZW5lcnMuZ2xvYmFsW2dsb2JhbEV2dHlwZV0uZGVsZXRlKGNvbXBvbmVudClcblx0XHR9XG5cdFx0Ly8gd2UgZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlIGEgbG9jYWwgb3IgbXVsdGkgbGlzdGVuZXJcblx0XHRsZXQgbWFwID0gbGlzdGVuZXJzLmxvY2FsXG5cdFx0bGV0IHRhcmdldEV2dHlwZSA9IGV2dHlwZVxuXHRcdGNvbnN0IG11bHRpRXZ0eXBlID0gZXh0cmFjdE11bHRpRXZ0eXBlKGV2dHlwZSlcblx0XHRpZiAobXVsdGlFdnR5cGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bWFwID0gbGlzdGVuZXJzLm11bHRpXG5cdFx0XHR0YXJnZXRFdnR5cGUgPSBtdWx0aUV2dHlwZVxuXHRcdH1cblx0XHQvLyBhbmQgdGhlbiByZW1vdmUgaXQgaGVyZVxuXHRcdG1hcC5nZXQoY29tcG9uZW50KVt0YXJnZXRFdnR5cGVdID0gdW5kZWZpbmVkXG5cdH1cblxuXHQvLyBwdWJsaWMgbWV0aG9kIGZvciByZW1vdmluZyBhIGxpc3RlbmVyXG5cdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGV2dHlwZSkge1xuXHRcdHJlbW92ZUxpc3RlbmVyKGVwaGVtZXJhbExpc3RlbmVycywgY29tcG9uZW50LCBldnR5cGUpXG5cdH1cblxuXHQvLyBwdWJsaWMgbWV0aG9kIGZvciByZW1vdmluZyBhIHBlcnNpc3RlbnQgbGlzdGVuZXJcblx0dGhpcy5yZW1vdmVQZXJzaXN0ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBldnR5cGUpIHtcblx0XHRyZW1vdmVMaXN0ZW5lcihwZXJzaXN0ZW50TGlzdGVuZXJzLCBjb21wb25lbnQsIGV2dHlwZSlcblx0fVxuXG5cdC8vIGhlbHBlciBmdW5jdGlubyB0aGF0IHJlbW92ZXMgYWxsIGxpc3RlbmVycyBmcm9tIGVpdGhlciBlcGhlbWVyYWwgb3IgcGVyc2lzdGVudCBsaXN0ZW5lcnNcblx0ZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzIChsaXN0ZW5lcnMsIGNvbXBvbmVudCkge1xuXHRcdGxpc3RlbmVycy5sb2NhbC5kZWxldGUoY29tcG9uZW50KVxuXHRcdGxpc3RlbmVycy5tdWx0aS5kZWxldGUoY29tcG9uZW50KVxuXHRcdGZvciAoY29uc3QgZXZ0eXBlIGluIGxpc3RlbmVycy5nbG9iYWwpIHtcblx0XHRcdGxpc3RlbmVycy5nbG9iYWxbZXZ0eXBlXS5kZWxldGUoY29tcG9uZW50KVxuXHRcdH1cblx0fVxuXG5cdC8vIHB1YmxpYyBtZXRob2QgZm9yIHJlbW92aW5nIGFsbCBldmVudCBsaXN0ZW5lcnNcblx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcblx0XHRyZW1vdmVMaXN0ZW5lcnMoZXBoZW1lcmFsTGlzdGVuZXJzLCBjb21wb25lbnQpXG5cdH1cblxuXHQvLyBwdWJsaWMgbWV0aG9kIGZvciByZW1vdmluZyBhbGwgcGVyc2lzdGVudCBsaXN0ZW5lcnNcblx0dGhpcy5yZW1vdmVQZXJzaXN0ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuXHRcdHJlbW92ZUxpc3RlbmVycyhwZXJzaXN0ZW50TGlzdGVuZXJzLCBjb21wb25lbnQpXG5cdH1cblxuXHR0aGlzLnJlbW92ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcblx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKGNvbXBvbmVudClcblx0XHR0aGlzLnJlbW92ZVBlcnNpc3RlbnRMaXN0ZW5lcnMoY29tcG9uZW50KVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERpc3BhdGNoXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/dispatch.js\n");

/***/ }),

/***/ "./src/lib/node.js":
/*!*************************!*\
  !*** ./src/lib/node.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-equal */ \"./node_modules/deep-equal/index.js\");\n/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_equal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var array_flatten__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! array-flatten */ \"./node_modules/array-flatten/array-flatten.js\");\n/* harmony import */ var array_flatten__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(array_flatten__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _constructor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constructor */ \"./src/lib/constructor.js\");\n\n\n\n\n\n// Nodes are the glue between components and Cute.\n// By wrapping the Node constructor in a closure, we supply all the necessary\n// components of Cute to each node\nfunction NodeContext(screen, scheduler, dispatch) {\n\tfunction Node(type, props, children) {\n\t\tthis.props = props || {};\n\t\tthis.x = this.props.x || 0;\n\t\tthis.y = this.props.y || 0;\n\t\tthis.w = this.props.w;\n\t\tthis.h = this.props.h;\n\t\tthis.transform = true;\n\t\tif (type.name) {\n\t\t\tthis.displayName = type.name;\n\t\t}\n\t\tif (children.length) {\n\t\t\tchildren = array_flatten__WEBPACK_IMPORTED_MODULE_1___default()(children);\n\t\t\tchildren = children.filter(child => {\n\t\t\t\treturn child instanceof Node;\n\t\t\t});\n\t\t\tif (children.length) {\n\t\t\t\tthis.props.children = children;\n\t\t\t}\n\t\t\t//console.log('000000000')\n\t\t\t//console.log(this.props.children)\n\t\t}\n\t\tif (this.props.ref) {\n\t\t\tthis.ref = this.props.ref;\n\t\t}\n\t\tif (this.props.key) {\n\t\t\tthis.key = this.props.key;\n\t\t}\n\t\tthis.type = type;\n\t}\n\n\tfunction isInteractiveComponent(node) {\n\t\treturn _constructor__WEBPACK_IMPORTED_MODULE_2__[\"default\"].prototype.isPrototypeOf(node.type.prototype);\n\t}\n\n\t// returns a rendered Node (or function if this node is a primitive)\n\tNode.prototype.render = function (props) {\n\t\t// pass own dimensions as defaults\n\t\tif (!('w' in props)) {\n\t\t\tprops.w = this.w;\n\t\t}\n\t\tif (!('h' in props)) {\n\t\t\tprops.h = this.h;\n\t\t}\n\t\t// this is a node that is an interactive Component that is being rerendered\n\t\tif (this.component) {\n\t\t\treturn this.component.render();\n\t\t}\n\t\t// if this is an interactive Component\n\t\tif (isInteractiveComponent(this)) {\n\t\t\tthis.component = new this.type(props);\n\t\t\tthis.component.node = this;\n\t\t\t// initialize state without triggering a rerender\n\t\t\tthis.component[this.component.state.name] && this.component[this.component.state.name]();\n\t\t\tif (this.ref) {\n\t\t\t\tif (this.ref instanceof Function) {\n\t\t\t\t\tthis.ref(this.component);\n\t\t\t\t} else {\n\t\t\t\t\tthis.ref.reference(this.component);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst ahhhh = this.component.render();\n\t\t\treturn ahhhh;\n\t\t}\n\t\treturn this.type(props);\n\t};\n\n\tNode.prototype.recursiveRender = function () {\n\t\t//console.log('rr')\n\t\t//console.log(this)\n\t\tthis.rendered = this.render(this.props);\n\t\t// this is some kind of component\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.setParent(this);\n\t\t\tthis.rendered.recursiveRender();\n\t\t\t// this is a primitive\n\t\t} else if (this.props.children) {\n\t\t\tthis.children = this.props.children;\n\t\t\tthis.props.children.forEach(child => {\n\t\t\t\t//console.log(child)\n\t\t\t\tchild.setParent(this);\n\t\t\t\tchild.recursiveRender();\n\t\t\t});\n\t\t}\n\t};\n\n\tNode.prototype.setParent = function (parent) {\n\t\tthis.parent = parent;\n\n\t\tif (isInteractiveComponent(this) && this.component) {\n\t\t\tthis.x = this.component.x;\n\t\t\tthis.y = this.component.y;\n\t\t}\n\n\t\tif (this.type.transform === false) {\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t}\n\n\t\tif (this.w === undefined) {\n\t\t\tthis.w = this.parent.w;\n\t\t}\n\t\tif (this.h === undefined) {\n\t\t\tthis.h = this.parent.h;\n\t\t}\n\n\t\tthis.screenX = this.x + this.parent.screenX;\n\t\tthis.screenY = this.y + this.parent.screenY;\n\t};\n\n\tfunction compareProps(a, b) {\n\t\tfor (const k in a) {\n\t\t\t// children have been reconciled, if they are simple-equivalent they're the same\n\t\t\t// children's props were compared as part of reconciliation\n\t\t\tif (k === 'children') {\n\t\t\t\tif (!('children' in b)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (a.children.length !== b.children.length) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < a.children.length; i++) {\n\t\t\t\t\tif (a.children[i] !== b.children[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (k === 'state') {\n\t\t\t\t// if state is updated, must rerender\n\t\t\t\tif (b.state.isUpdated) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// feels like there must be a better way to do this\n\t\t\tif (a[k] instanceof Function && b[k] instanceof Function) {\n\t\t\t\tif (a[k] === b[k]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (a[k].toString() === b[k].toString()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!deep_equal__WEBPACK_IMPORTED_MODULE_0___default()(a[k], b[k])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// plausible that we don't need this check\n\t\tfor (const k in b) {\n\t\t\tif (!(k in a)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// sets own props to new props. sets own isUpdated property if props or children are updated\n\tNode.prototype.receiveProps = function (props) {\n\t\t//console.log('receive props')\n\t\t//console.log(this.component || this.displayName)\n\t\t//console.log(props)\n\n\t\tconst childMap = new MultiMap(this.children);\n\n\t\tif (this.children !== undefined && props.children !== undefined) {\n\t\t\t//console.log('has children')\n\t\t\tprops.children = props.children.map(newChild => {\n\t\t\t\tconst oldChild = childMap.match(newChild);\n\t\t\t\t//return oldChild || newChild\n\t\t\t\tif (oldChild === undefined) {\n\t\t\t\t\treturn newChild;\n\t\t\t\t}\n\t\t\t\t//console.log('new child props')\n\t\t\t\t//console.log(newChild.props)\n\t\t\t\toldChild.receiveProps(newChild.props);\n\t\t\t\t//childrenUpdated = childrenUpdated || oldChild.isUpdated || oldChild.propsUpdated\n\t\t\t\treturn oldChild;\n\t\t\t});\n\t\t}\n\n\t\t// destroy any nodes left over\n\t\tchildMap.forEach(node => {\n\t\t\tnode.destroy();\n\t\t});\n\n\t\t//this.children = props.children\n\n\t\tthis.propsUpdated = compareProps(this.props, props);\n\t\tthis.props = props;\n\t\tif (this.propsUpdated && this.component) {\n\t\t\tthis.component._receiveProps(this.props);\n\t\t}\n\t};\n\n\tNode.prototype.rerender = function () {\n\t\t//console.log('rerender')\n\t\t//console.log(this.component || this.displayName)\n\t\t//if (screen.renderMap.has(this)) {\n\t\t//console.log('rerendered more than once')\n\t\t//console.log(this)\n\t\t//} else {\n\t\t//screen.renderMap.set(this, this)\n\t\t//}\n\n\t\tif (!this.isUpdated && !this.propsUpdated) {\n\t\t\t//console.log('xxxxxxx')\n\t\t\t//console.log(this)\n\t\t\tif (this.rendered instanceof Node) {\n\t\t\t\tthis.rendered.setParent(this);\n\t\t\t\tthis.rendered.rerender();\n\t\t\t}\n\t\t\tif (this.children) {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\tchild.setParent(this);\n\t\t\t\t\tchild.rerender();\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t//console.log('yyyyyyy')\n\t\t\t//console.log(this)\n\t\t\tconst rerendered = this.render(this.props);\n\n\t\t\tif (!(rerendered instanceof Node)) {\n\t\t\t\tthis.rendered = rerendered;\n\t\t\t\tthis.children = this.props.children;\n\t\t\t\tif (this.children) {\n\t\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\t\tchild.setParent(this);\n\t\t\t\t\t\tif (child.rendered) {\n\t\t\t\t\t\t\tchild.rerender();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchild.recursiveRender();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (this.rendered.type === rerendered.type) {\n\t\t\t\tthis.rendered.setParent(this);\n\t\t\t\tthis.rendered.receiveProps(rerendered.props);\n\t\t\t\tthis.rendered.rerender();\n\t\t\t} else {\n\t\t\t\tthis.rendered = rerendered;\n\t\t\t\tthis.rendered.setParent(this);\n\t\t\t\tthis.rendered.recursiveRender();\n\t\t\t}\n\t\t}\n\n\t\t// reset flags\n\t\tthis.isUpdated = false;\n\t\tthis.propsUpdated = false;\n\t\tif (this.component) {\n\t\t\tthis.component.state.isUpdated = false;\n\t\t}\n\t};\n\n\tNode.prototype.recursiveUpdate = function (time) {\n\t\tif (this.rendered instanceof Node) {\n\t\t\t//console.log('updatinggggg')\n\t\t\t//console.log(this.component)\n\t\t\t//console.log(this.component.update)\n\t\t\tif (this.component && this.component.update) {\n\t\t\t\tthis.component.update(time);\n\t\t\t}\n\t\t\tthis.rendered.recursiveUpdate(time);\n\t\t} else {\n\t\t\tif (this.children) {\n\t\t\t\tthis.children.forEach(child => {\n\t\t\t\t\tchild.recursiveUpdate(time);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\tNode.prototype.recursiveMove = function () {\n\t\tif (this.isMoved) {\n\t\t\tthis.x = this.component.x;\n\t\t\tthis.y = this.component.y;\n\t\t}\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.setParent(this);\n\t\t\tthis.rendered.recursiveMove();\n\t\t}\n\t\tif (this.children) {\n\t\t\tthis.children.forEach(child => {\n\t\t\t\tchild.setParent(this);\n\t\t\t\tchild.recursiveMove();\n\t\t\t});\n\t\t}\n\t\tthis.isMoved = false;\n\t};\n\n\tNode.prototype.draw = function (ctx) {\n\t\tif (this.transform) {\n\t\t\tctx.save();\n\t\t\t// ctx.scale\n\t\t\t// ctx.rotate\n\t\t\tctx.translate(this.x, this.y);\n\t\t}\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.draw(ctx);\n\t\t} else {\n\t\t\t// call primitive draw function\n\t\t\tthis.rendered(ctx);\n\t\t}\n\t\tif (this.transform) {\n\t\t\tctx.restore();\n\t\t}\n\t};\n\n\tNode.prototype.scheduleUpdate = function () {\n\t\tscheduler.scheduleUpdate(this);\n\t};\n\n\t// this can only ever be called from interactive component nodes\n\tNode.prototype.scheduleRender = function () {\n\t\t// schedule a rerender\n\t\tthis.isUpdated = true;\n\t\tscheduler.scheduleRender(this);\n\t};\n\n\tNode.prototype.scheduleMove = function () {\n\t\tthis.isMoved = true;\n\t\tscheduler.scheduleMove(this);\n\t};\n\n\tNode.prototype.addEventListener = function (component, evtype, handler) {\n\t\tdispatch.addEventListener(component, evtype, handler);\n\t};\n\n\tNode.prototype.removeEventListeners = function (component) {\n\t\tdispatch.removeEventListeners(component);\n\t};\n\n\tNode.prototype.addPersistentListener = function (component, evtype, handler) {\n\t\tdispatch.addPersistentListener(component, evtype, handler);\n\t};\n\n\tNode.prototype.removePersistentListener = function (component, evtype) {\n\t\tdispatch.removePersistentListener(component, evtype);\n\t};\n\n\tNode.prototype.getCollisions = function (component) {\n\t\treturn screen.getIntersections(component);\n\t}, Node.prototype.destroy = function () {\n\t\tif (this.rendered instanceof Node) {\n\t\t\tthis.rendered.destroy();\n\t\t}\n\t\tif (this.children) {\n\t\t\tthis.children.forEach(child => {\n\t\t\t\tchild.destroy();\n\t\t\t});\n\t\t}\n\t\tif (this.component) {\n\t\t\tdispatch.removeComponent(this.component);\n\t\t\tif (this.component.destroy) {\n\t\t\t\tthis.component.destroy.call(this.component);\n\t\t\t}\n\t\t}\n\t\t// scheduler.scheduleRender(this)\n\t\t// I mean that can't be right, we're trying to disappear, why would we need to rerender?\n\t};\n\n\treturn Node;\n}\n\n// returns the component's key if it exists, otherwise the type\nfunction getKey(node) {\n\treturn node.key || node.type;\n}\n\n// A Map that allows multiple insertions to the same key. Powers the children diffing algorithm.\nfunction MultiMap(children) {\n\tthis.map = new Map();\n\tthis.indexMap = new Map();\n\n\tif (children) {\n\t\tfor (const node of children) {\n\t\t\tconst key = getKey(node);\n\t\t\tif (this.map.has(key)) {\n\t\t\t\tthis.map.get(key).push(node);\n\t\t\t} else {\n\t\t\t\tthis.map.set(key, [node]);\n\t\t\t\tthis.indexMap.set(key, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// attempt to find a matching node and if found, \"remove\" it from the multi-map (by incrementing index)\nMultiMap.prototype.match = function (node) {\n\tconst key = getKey(node);\n\tconst array = this.map.get(key);\n\tif (array === undefined) {\n\t\treturn undefined;\n\t}\n\tconst index = this.indexMap.get(key);\n\tthis.indexMap.set(key, index + 1);\n\treturn array[index];\n};\n\n// loop over remaining nodes after a series of pops\nMultiMap.prototype.forEach = function (fn) {\n\tthis.map.forEach((array, key) => {\n\t\tfor (let i = this.indexMap.get(key); i < array.length; i++) {\n\t\t\tfn(array[i]);\n\t\t}\n\t});\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (NodeContext);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL25vZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9ub2RlLmpzP2JhZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlZXBFcXVhbCBmcm9tICdkZWVwLWVxdWFsJ1xyXG5pbXBvcnQgZmxhdHRlbiBmcm9tICdhcnJheS1mbGF0dGVuJ1xyXG5cclxuaW1wb3J0IENvbnN0cnVjdG9yIGZyb20gJy4vY29uc3RydWN0b3InXHJcblxyXG4vLyBOb2RlcyBhcmUgdGhlIGdsdWUgYmV0d2VlbiBjb21wb25lbnRzIGFuZCBDdXRlLlxyXG4vLyBCeSB3cmFwcGluZyB0aGUgTm9kZSBjb25zdHJ1Y3RvciBpbiBhIGNsb3N1cmUsIHdlIHN1cHBseSBhbGwgdGhlIG5lY2Vzc2FyeVxyXG4vLyBjb21wb25lbnRzIG9mIEN1dGUgdG8gZWFjaCBub2RlXHJcbmZ1bmN0aW9uIE5vZGVDb250ZXh0IChzY3JlZW4sIHNjaGVkdWxlciwgZGlzcGF0Y2gpIHtcclxuXHRmdW5jdGlvbiBOb2RlICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcclxuXHRcdHRoaXMucHJvcHMgPSBwcm9wcyB8fCB7fVxyXG5cdFx0dGhpcy54ID0gdGhpcy5wcm9wcy54IHx8IDBcclxuXHRcdHRoaXMueSA9IHRoaXMucHJvcHMueSB8fCAwXHJcblx0XHR0aGlzLncgPSB0aGlzLnByb3BzLndcclxuXHRcdHRoaXMuaCA9IHRoaXMucHJvcHMuaFxyXG5cdFx0dGhpcy50cmFuc2Zvcm0gPSB0cnVlXHJcblx0XHRpZiAodHlwZS5uYW1lKSB7XHJcblx0XHRcdHRoaXMuZGlzcGxheU5hbWUgPSB0eXBlLm5hbWVcclxuXHRcdH1cclxuXHRcdGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0Y2hpbGRyZW4gPSBmbGF0dGVuKGNoaWxkcmVuKVxyXG5cdFx0XHRjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiB7XHJcblx0XHRcdFx0cmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgTm9kZVxyXG5cdFx0XHR9KVxyXG5cdFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhpcy5wcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuXHJcblx0XHRcdH1cclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnMDAwMDAwMDAwJylcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyh0aGlzLnByb3BzLmNoaWxkcmVuKVxyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMucHJvcHMucmVmKSB7XHJcblx0XHRcdHRoaXMucmVmID0gdGhpcy5wcm9wcy5yZWZcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLnByb3BzLmtleSkge1xyXG5cdFx0XHR0aGlzLmtleSA9IHRoaXMucHJvcHMua2V5XHJcblx0XHR9XHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc0ludGVyYWN0aXZlQ29tcG9uZW50IChub2RlKSB7XHJcblx0XHRyZXR1cm4gQ29uc3RydWN0b3IucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yobm9kZS50eXBlLnByb3RvdHlwZSlcclxuXHR9XHJcblxyXG5cdC8vIHJldHVybnMgYSByZW5kZXJlZCBOb2RlIChvciBmdW5jdGlvbiBpZiB0aGlzIG5vZGUgaXMgYSBwcmltaXRpdmUpXHJcblx0Tm9kZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcblx0XHQvLyBwYXNzIG93biBkaW1lbnNpb25zIGFzIGRlZmF1bHRzXHJcblx0XHRpZiAoISgndycgaW4gcHJvcHMpKSB7XHJcblx0XHRcdHByb3BzLncgPSB0aGlzLndcclxuXHRcdH1cclxuXHRcdGlmICghKCdoJyBpbiBwcm9wcykpIHtcclxuXHRcdFx0cHJvcHMuaCA9IHRoaXMuaFxyXG5cdFx0fVxyXG5cdFx0Ly8gdGhpcyBpcyBhIG5vZGUgdGhhdCBpcyBhbiBpbnRlcmFjdGl2ZSBDb21wb25lbnQgdGhhdCBpcyBiZWluZyByZXJlbmRlcmVkXHJcblx0XHRpZiAodGhpcy5jb21wb25lbnQpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcG9uZW50LnJlbmRlcigpXHJcblx0XHR9XHJcblx0XHQvLyBpZiB0aGlzIGlzIGFuIGludGVyYWN0aXZlIENvbXBvbmVudFxyXG5cdFx0aWYgKGlzSW50ZXJhY3RpdmVDb21wb25lbnQodGhpcykpIHtcclxuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBuZXcgdGhpcy50eXBlKHByb3BzKVxyXG5cdFx0XHR0aGlzLmNvbXBvbmVudC5ub2RlID0gdGhpc1xyXG5cdFx0XHQvLyBpbml0aWFsaXplIHN0YXRlIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlcmVuZGVyXHJcblx0XHRcdHRoaXMuY29tcG9uZW50W3RoaXMuY29tcG9uZW50LnN0YXRlLm5hbWVdICYmXHJcblx0XHRcdFx0dGhpcy5jb21wb25lbnRbdGhpcy5jb21wb25lbnQuc3RhdGUubmFtZV0oKVxyXG5cdFx0XHRpZiAodGhpcy5yZWYpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5yZWYgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG5cdFx0XHRcdFx0dGhpcy5yZWYodGhpcy5jb21wb25lbnQpXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMucmVmLnJlZmVyZW5jZSh0aGlzLmNvbXBvbmVudClcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3QgYWhoaGggPSB0aGlzLmNvbXBvbmVudC5yZW5kZXIoKVxyXG5cdFx0XHRyZXR1cm4gYWhoaGhcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnR5cGUocHJvcHMpXHJcblx0fVxyXG5cclxuXHROb2RlLnByb3RvdHlwZS5yZWN1cnNpdmVSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQvL2NvbnNvbGUubG9nKCdycicpXHJcblx0XHQvL2NvbnNvbGUubG9nKHRoaXMpXHJcblx0XHR0aGlzLnJlbmRlcmVkID0gdGhpcy5yZW5kZXIodGhpcy5wcm9wcylcclxuXHRcdC8vIHRoaXMgaXMgc29tZSBraW5kIG9mIGNvbXBvbmVudFxyXG5cdFx0aWYgKHRoaXMucmVuZGVyZWQgaW5zdGFuY2VvZiBOb2RlKSB7XHJcblx0XHRcdHRoaXMucmVuZGVyZWQuc2V0UGFyZW50KHRoaXMpXHJcblx0XHRcdHRoaXMucmVuZGVyZWQucmVjdXJzaXZlUmVuZGVyKClcclxuXHRcdC8vIHRoaXMgaXMgYSBwcmltaXRpdmVcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbikge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlblxyXG5cdFx0XHR0aGlzLnByb3BzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coY2hpbGQpXHJcblx0XHRcdFx0Y2hpbGQuc2V0UGFyZW50KHRoaXMpXHJcblx0XHRcdFx0Y2hpbGQucmVjdXJzaXZlUmVuZGVyKClcclxuXHRcdFx0fSlcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdE5vZGUucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50XHJcblxyXG5cdFx0aWYgKGlzSW50ZXJhY3RpdmVDb21wb25lbnQodGhpcykgJiYgdGhpcy5jb21wb25lbnQpIHtcclxuXHRcdFx0dGhpcy54ID0gdGhpcy5jb21wb25lbnQueFxyXG5cdFx0XHR0aGlzLnkgPSB0aGlzLmNvbXBvbmVudC55XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMudHlwZS50cmFuc2Zvcm0gPT09IGZhbHNlKSB7XHJcblx0XHRcdHRoaXMueCA9IDBcclxuXHRcdFx0dGhpcy55ID0gMFxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLncgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLncgPSB0aGlzLnBhcmVudC53XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5oID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5oID0gdGhpcy5wYXJlbnQuaFxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2NyZWVuWCA9IHRoaXMueCArIHRoaXMucGFyZW50LnNjcmVlblhcclxuXHRcdHRoaXMuc2NyZWVuWSA9IHRoaXMueSArIHRoaXMucGFyZW50LnNjcmVlbllcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNvbXBhcmVQcm9wcyAoYSwgYikge1xyXG5cdFx0Zm9yIChjb25zdCBrIGluIGEpIHtcclxuXHRcdFx0Ly8gY2hpbGRyZW4gaGF2ZSBiZWVuIHJlY29uY2lsZWQsIGlmIHRoZXkgYXJlIHNpbXBsZS1lcXVpdmFsZW50IHRoZXkncmUgdGhlIHNhbWVcclxuXHRcdFx0Ly8gY2hpbGRyZW4ncyBwcm9wcyB3ZXJlIGNvbXBhcmVkIGFzIHBhcnQgb2YgcmVjb25jaWxpYXRpb25cclxuXHRcdFx0aWYgKGsgPT09ICdjaGlsZHJlbicpIHtcclxuXHRcdFx0XHRpZiAoISgnY2hpbGRyZW4nIGluIGIpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoYS5jaGlsZHJlbi5sZW5ndGggIT09IGIuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChhLmNoaWxkcmVuW2ldICE9PSBiLmNoaWxkcmVuW2ldKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGsgPT09ICdzdGF0ZScpIHtcclxuXHRcdFx0XHQvLyBpZiBzdGF0ZSBpcyB1cGRhdGVkLCBtdXN0IHJlcmVuZGVyXHJcblx0XHRcdFx0aWYgKGIuc3RhdGUuaXNVcGRhdGVkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGZlZWxzIGxpa2UgdGhlcmUgbXVzdCBiZSBhIGJldHRlciB3YXkgdG8gZG8gdGhpc1xyXG5cdFx0XHRpZiAoYVtrXSBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIGJba10gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG5cdFx0XHRcdGlmIChhW2tdID09PSBiW2tdKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoYVtrXS50b1N0cmluZygpID09PSBiW2tdLnRvU3RyaW5nKCkpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghZGVlcEVxdWFsKGFba10sIGJba10pKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gcGxhdXNpYmxlIHRoYXQgd2UgZG9uJ3QgbmVlZCB0aGlzIGNoZWNrXHJcblx0XHRmb3IgKGNvbnN0IGsgaW4gYikge1xyXG5cdFx0XHRpZiAoIShrIGluIGEpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlXHJcblx0fVxyXG5cclxuXHQvLyBzZXRzIG93biBwcm9wcyB0byBuZXcgcHJvcHMuIHNldHMgb3duIGlzVXBkYXRlZCBwcm9wZXJ0eSBpZiBwcm9wcyBvciBjaGlsZHJlbiBhcmUgdXBkYXRlZFxyXG5cdE5vZGUucHJvdG90eXBlLnJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdFx0Ly9jb25zb2xlLmxvZygncmVjZWl2ZSBwcm9wcycpXHJcblx0XHQvL2NvbnNvbGUubG9nKHRoaXMuY29tcG9uZW50IHx8IHRoaXMuZGlzcGxheU5hbWUpXHJcblx0XHQvL2NvbnNvbGUubG9nKHByb3BzKVxyXG5cdFx0XHJcblx0XHRjb25zdCBjaGlsZE1hcCA9IG5ldyBNdWx0aU1hcCh0aGlzLmNoaWxkcmVuKVxyXG5cclxuXHRcdGlmICh0aGlzLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdoYXMgY2hpbGRyZW4nKVxyXG5cdFx0XHRwcm9wcy5jaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLm1hcChuZXdDaGlsZCA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgb2xkQ2hpbGQgPSBjaGlsZE1hcC5tYXRjaChuZXdDaGlsZClcclxuXHRcdFx0XHQvL3JldHVybiBvbGRDaGlsZCB8fCBuZXdDaGlsZFxyXG5cdFx0XHRcdGlmIChvbGRDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3Q2hpbGRcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnbmV3IGNoaWxkIHByb3BzJylcclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKG5ld0NoaWxkLnByb3BzKVxyXG5cdFx0XHRcdG9sZENoaWxkLnJlY2VpdmVQcm9wcyhuZXdDaGlsZC5wcm9wcylcclxuXHRcdFx0XHQvL2NoaWxkcmVuVXBkYXRlZCA9IGNoaWxkcmVuVXBkYXRlZCB8fCBvbGRDaGlsZC5pc1VwZGF0ZWQgfHwgb2xkQ2hpbGQucHJvcHNVcGRhdGVkXHJcblx0XHRcdFx0cmV0dXJuIG9sZENoaWxkXHJcblx0XHRcdH0pXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRlc3Ryb3kgYW55IG5vZGVzIGxlZnQgb3ZlclxyXG5cdFx0Y2hpbGRNYXAuZm9yRWFjaChub2RlID0+IHtcclxuXHRcdFx0bm9kZS5kZXN0cm95KClcclxuXHRcdH0pXHJcblxyXG5cdFx0Ly90aGlzLmNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW5cclxuXHJcblx0XHR0aGlzLnByb3BzVXBkYXRlZCA9IGNvbXBhcmVQcm9wcyh0aGlzLnByb3BzLCBwcm9wcylcclxuXHRcdHRoaXMucHJvcHMgPSBwcm9wc1xyXG5cdFx0aWYgKHRoaXMucHJvcHNVcGRhdGVkICYmIHRoaXMuY29tcG9uZW50KSB7XHJcblx0XHRcdHRoaXMuY29tcG9uZW50Ll9yZWNlaXZlUHJvcHModGhpcy5wcm9wcylcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdE5vZGUucHJvdG90eXBlLnJlcmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly9jb25zb2xlLmxvZygncmVyZW5kZXInKVxyXG5cdFx0Ly9jb25zb2xlLmxvZyh0aGlzLmNvbXBvbmVudCB8fCB0aGlzLmRpc3BsYXlOYW1lKVxyXG5cdFx0Ly9pZiAoc2NyZWVuLnJlbmRlck1hcC5oYXModGhpcykpIHtcclxuXHRcdC8vY29uc29sZS5sb2coJ3JlcmVuZGVyZWQgbW9yZSB0aGFuIG9uY2UnKVxyXG5cdFx0Ly9jb25zb2xlLmxvZyh0aGlzKVxyXG5cdFx0Ly99IGVsc2Uge1xyXG5cdFx0Ly9zY3JlZW4ucmVuZGVyTWFwLnNldCh0aGlzLCB0aGlzKVxyXG5cdFx0Ly99XHJcblxyXG5cdFx0aWYgKCF0aGlzLmlzVXBkYXRlZCAmJiAhdGhpcy5wcm9wc1VwZGF0ZWQpIHtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZygneHh4eHh4eCcpXHJcblx0XHRcdC8vY29uc29sZS5sb2codGhpcylcclxuXHRcdFx0aWYgKHRoaXMucmVuZGVyZWQgaW5zdGFuY2VvZiBOb2RlKSB7XHJcblx0XHRcdFx0dGhpcy5yZW5kZXJlZC5zZXRQYXJlbnQodGhpcylcclxuXHRcdFx0XHR0aGlzLnJlbmRlcmVkLnJlcmVuZGVyKClcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcblx0XHRcdFx0XHRjaGlsZC5zZXRQYXJlbnQodGhpcylcclxuXHRcdFx0XHRcdGNoaWxkLnJlcmVuZGVyKClcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCd5eXl5eXl5JylcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyh0aGlzKVxyXG5cdFx0XHRjb25zdCByZXJlbmRlcmVkID0gdGhpcy5yZW5kZXIodGhpcy5wcm9wcylcclxuXHJcblx0XHRcdGlmICghKHJlcmVuZGVyZWQgaW5zdGFuY2VvZiBOb2RlKSkge1xyXG5cdFx0XHRcdHRoaXMucmVuZGVyZWQgPSByZXJlbmRlcmVkXHJcblx0XHRcdFx0dGhpcy5jaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW5cclxuXHRcdFx0XHRpZiAodGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuXHRcdFx0XHRcdFx0Y2hpbGQuc2V0UGFyZW50KHRoaXMpXHJcblx0XHRcdFx0XHRcdGlmIChjaGlsZC5yZW5kZXJlZCkge1xyXG5cdFx0XHRcdFx0XHRcdGNoaWxkLnJlcmVuZGVyKClcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRjaGlsZC5yZWN1cnNpdmVSZW5kZXIoKVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnJlbmRlcmVkLnR5cGUgPT09IHJlcmVuZGVyZWQudHlwZSkge1xyXG5cdFx0XHRcdHRoaXMucmVuZGVyZWQuc2V0UGFyZW50KHRoaXMpXHJcblx0XHRcdFx0dGhpcy5yZW5kZXJlZC5yZWNlaXZlUHJvcHMocmVyZW5kZXJlZC5wcm9wcylcclxuXHRcdFx0XHR0aGlzLnJlbmRlcmVkLnJlcmVuZGVyKClcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnJlbmRlcmVkID0gcmVyZW5kZXJlZFxyXG5cdFx0XHRcdHRoaXMucmVuZGVyZWQuc2V0UGFyZW50KHRoaXMpXHJcblx0XHRcdFx0dGhpcy5yZW5kZXJlZC5yZWN1cnNpdmVSZW5kZXIoKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzZXQgZmxhZ3NcclxuXHRcdHRoaXMuaXNVcGRhdGVkID0gZmFsc2VcclxuXHRcdHRoaXMucHJvcHNVcGRhdGVkID0gZmFsc2VcclxuXHRcdGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG5cdFx0XHR0aGlzLmNvbXBvbmVudC5zdGF0ZS5pc1VwZGF0ZWQgPSBmYWxzZVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Tm9kZS5wcm90b3R5cGUucmVjdXJzaXZlVXBkYXRlID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuXHRcdGlmICh0aGlzLnJlbmRlcmVkIGluc3RhbmNlb2YgTm9kZSkge1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCd1cGRhdGluZ2dnZ2cnKVxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHRoaXMuY29tcG9uZW50KVxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHRoaXMuY29tcG9uZW50LnVwZGF0ZSlcclxuXHRcdFx0aWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuY29tcG9uZW50LnVwZGF0ZSkge1xyXG5cdFx0XHRcdHRoaXMuY29tcG9uZW50LnVwZGF0ZSh0aW1lKVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucmVuZGVyZWQucmVjdXJzaXZlVXBkYXRlKHRpbWUpXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodGhpcy5jaGlsZHJlbikge1xyXG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcblx0XHRcdFx0XHRjaGlsZC5yZWN1cnNpdmVVcGRhdGUodGltZSlcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0Tm9kZS5wcm90b3R5cGUucmVjdXJzaXZlTW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLmlzTW92ZWQpIHtcclxuXHRcdFx0dGhpcy54ID0gdGhpcy5jb21wb25lbnQueFxyXG5cdFx0XHR0aGlzLnkgPSB0aGlzLmNvbXBvbmVudC55XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5yZW5kZXJlZCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuXHRcdFx0dGhpcy5yZW5kZXJlZC5zZXRQYXJlbnQodGhpcylcclxuXHRcdFx0dGhpcy5yZW5kZXJlZC5yZWN1cnNpdmVNb3ZlKClcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLmNoaWxkcmVuKSB7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcblx0XHRcdFx0Y2hpbGQuc2V0UGFyZW50KHRoaXMpXHJcblx0XHRcdFx0Y2hpbGQucmVjdXJzaXZlTW92ZSgpXHJcblx0XHRcdH0pXHJcblx0XHR9XHJcblx0XHR0aGlzLmlzTW92ZWQgPSBmYWxzZVxyXG5cdH1cclxuXHJcblx0Tm9kZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjdHgpIHtcclxuXHRcdGlmICh0aGlzLnRyYW5zZm9ybSkge1xyXG5cdFx0XHRjdHguc2F2ZSgpXHJcblx0XHRcdC8vIGN0eC5zY2FsZVxyXG5cdFx0XHQvLyBjdHgucm90YXRlXHJcblx0XHRcdGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpXHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5yZW5kZXJlZCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuXHRcdFx0dGhpcy5yZW5kZXJlZC5kcmF3KGN0eClcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGNhbGwgcHJpbWl0aXZlIGRyYXcgZnVuY3Rpb25cclxuXHRcdFx0dGhpcy5yZW5kZXJlZChjdHgpXHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy50cmFuc2Zvcm0pIHtcclxuXHRcdFx0Y3R4LnJlc3RvcmUoKVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Tm9kZS5wcm90b3R5cGUuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRzY2hlZHVsZXIuc2NoZWR1bGVVcGRhdGUodGhpcylcclxuXHR9XHJcblxyXG5cdC8vIHRoaXMgY2FuIG9ubHkgZXZlciBiZSBjYWxsZWQgZnJvbSBpbnRlcmFjdGl2ZSBjb21wb25lbnQgbm9kZXNcclxuXHROb2RlLnByb3RvdHlwZS5zY2hlZHVsZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIHNjaGVkdWxlIGEgcmVyZW5kZXJcclxuXHRcdHRoaXMuaXNVcGRhdGVkID0gdHJ1ZVxyXG5cdFx0c2NoZWR1bGVyLnNjaGVkdWxlUmVuZGVyKHRoaXMpXHJcblx0fVxyXG5cclxuXHROb2RlLnByb3RvdHlwZS5zY2hlZHVsZU1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmlzTW92ZWQgPSB0cnVlXHJcblx0XHRzY2hlZHVsZXIuc2NoZWR1bGVNb3ZlKHRoaXMpXHJcblx0fVxyXG5cclxuXHROb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgZXZ0eXBlLCBoYW5kbGVyKSB7XHJcblx0XHRkaXNwYXRjaC5hZGRFdmVudExpc3RlbmVyKGNvbXBvbmVudCwgZXZ0eXBlLCBoYW5kbGVyKVxyXG5cdH1cclxuXHJcblx0Tm9kZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XHJcblx0XHRkaXNwYXRjaC5yZW1vdmVFdmVudExpc3RlbmVycyhjb21wb25lbnQpXHJcblx0fVxyXG5cclxuXHROb2RlLnByb3RvdHlwZS5hZGRQZXJzaXN0ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBldnR5cGUsIGhhbmRsZXIpIHtcclxuXHRcdGRpc3BhdGNoLmFkZFBlcnNpc3RlbnRMaXN0ZW5lcihjb21wb25lbnQsIGV2dHlwZSwgaGFuZGxlcilcclxuXHR9XHJcblxyXG5cdE5vZGUucHJvdG90eXBlLnJlbW92ZVBlcnNpc3RlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGV2dHlwZSkge1xyXG5cdFx0ZGlzcGF0Y2gucmVtb3ZlUGVyc2lzdGVudExpc3RlbmVyKGNvbXBvbmVudCwgZXZ0eXBlKVxyXG5cdH1cclxuXHJcblx0Tm9kZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9ucyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuXHRcdHJldHVybiBzY3JlZW4uZ2V0SW50ZXJzZWN0aW9ucyhjb21wb25lbnQpXHJcblx0fSxcclxuXHJcblx0Tm9kZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLnJlbmRlcmVkIGluc3RhbmNlb2YgTm9kZSkge1xyXG5cdFx0XHR0aGlzLnJlbmRlcmVkLmRlc3Ryb3koKVxyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuY2hpbGRyZW4pIHtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuXHRcdFx0XHRjaGlsZC5kZXN0cm95KClcclxuXHRcdFx0fSlcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG5cdFx0XHRkaXNwYXRjaC5yZW1vdmVDb21wb25lbnQodGhpcy5jb21wb25lbnQpXHJcblx0XHRcdGlmICh0aGlzLmNvbXBvbmVudC5kZXN0cm95KSB7XHJcblx0XHRcdFx0dGhpcy5jb21wb25lbnQuZGVzdHJveS5jYWxsKHRoaXMuY29tcG9uZW50KVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBzY2hlZHVsZXIuc2NoZWR1bGVSZW5kZXIodGhpcylcclxuXHRcdC8vIEkgbWVhbiB0aGF0IGNhbid0IGJlIHJpZ2h0LCB3ZSdyZSB0cnlpbmcgdG8gZGlzYXBwZWFyLCB3aHkgd291bGQgd2UgbmVlZCB0byByZXJlbmRlcj9cclxuXHR9XHJcblxyXG5cdHJldHVybiBOb2RlXHJcbn1cclxuXHJcbi8vIHJldHVybnMgdGhlIGNvbXBvbmVudCdzIGtleSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB0aGUgdHlwZVxyXG5mdW5jdGlvbiBnZXRLZXkgKG5vZGUpIHtcclxuXHRyZXR1cm4gbm9kZS5rZXkgfHwgbm9kZS50eXBlXHJcbn1cclxuXHJcbi8vIEEgTWFwIHRoYXQgYWxsb3dzIG11bHRpcGxlIGluc2VydGlvbnMgdG8gdGhlIHNhbWUga2V5LiBQb3dlcnMgdGhlIGNoaWxkcmVuIGRpZmZpbmcgYWxnb3JpdGhtLlxyXG5mdW5jdGlvbiBNdWx0aU1hcCAoY2hpbGRyZW4pIHtcclxuXHR0aGlzLm1hcCA9IG5ldyBNYXAoKVxyXG5cdHRoaXMuaW5kZXhNYXAgPSBuZXcgTWFwKClcclxuXHJcblx0aWYgKGNoaWxkcmVuKSB7XHJcblx0XHRmb3IgKGNvbnN0IG5vZGUgb2YgY2hpbGRyZW4pIHtcclxuXHRcdFx0Y29uc3Qga2V5ID0gZ2V0S2V5KG5vZGUpXHJcblx0XHRcdGlmICh0aGlzLm1hcC5oYXMoa2V5KSkge1xyXG5cdFx0XHRcdHRoaXMubWFwLmdldChrZXkpLnB1c2gobm9kZSlcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm1hcC5zZXQoa2V5LCBbbm9kZV0pXHJcblx0XHRcdFx0dGhpcy5pbmRleE1hcC5zZXQoa2V5LCAwKVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBhdHRlbXB0IHRvIGZpbmQgYSBtYXRjaGluZyBub2RlIGFuZCBpZiBmb3VuZCwgXCJyZW1vdmVcIiBpdCBmcm9tIHRoZSBtdWx0aS1tYXAgKGJ5IGluY3JlbWVudGluZyBpbmRleClcclxuTXVsdGlNYXAucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHRjb25zdCBrZXkgPSBnZXRLZXkobm9kZSlcclxuXHRjb25zdCBhcnJheSA9IHRoaXMubWFwLmdldChrZXkpXHJcblx0aWYgKGFycmF5ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiB1bmRlZmluZWRcclxuXHR9XHJcblx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4TWFwLmdldChrZXkpXHJcblx0dGhpcy5pbmRleE1hcC5zZXQoa2V5LCBpbmRleCArIDEpXHJcblx0cmV0dXJuIGFycmF5W2luZGV4XVxyXG59XHJcblxyXG4vLyBsb29wIG92ZXIgcmVtYWluaW5nIG5vZGVzIGFmdGVyIGEgc2VyaWVzIG9mIHBvcHNcclxuTXVsdGlNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcclxuXHR0aGlzLm1hcC5mb3JFYWNoKChhcnJheSwga2V5KSA9PiB7XHJcblx0XHRmb3IgKGxldCBpID0gdGhpcy5pbmRleE1hcC5nZXQoa2V5KTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGZuKGFycmF5W2ldKVxyXG5cdFx0fVxyXG5cdH0pXHJcbn1cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlQ29udGV4dFxyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/node.js\n");

/***/ }),

/***/ "./src/lib/primitives.js":
/*!*******************************!*\
  !*** ./src/lib/primitives.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction drawChildren(props, ctx) {\n\tif (props.children !== undefined) {\n\t\tfor (const childNode of props.children) {\n\t\t\tchildNode.draw(ctx);\n\t\t}\n\t}\n}\n\nconst primitives = {\n\t/*\n  * renders its children and does nothing else\n  */\n\tlayer(props) {\n\t\treturn ctx => {\n\t\t\tctx.save();\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\t/*\n  * creates a rectangular path for stroking/filling\n  * calls ctx.rect() then renders any children\n  */\n\trect(props) {\n\t\treturn ctx => {\n\t\t\tctx.save();\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(0, 0, props.w, props.h);\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\t/*\n  * fills its enclosing path\n  * calls ctx.fill()\n  */\n\tfill(props) {\n\t\treturn ctx => {\n\t\t\tctx.save();\n\t\t\tif (props.color) {\n\t\t\t\tctx.fillStyle = props.color;\n\t\t\t}\n\t\t\tctx.fill();\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\tstroke(props) {\n\t\treturn ctx => {\n\t\t\tctx.save();\n\t\t\tif (props.color) {\n\t\t\t\tctx.strokeStyle = props.color;\n\t\t\t}\n\t\t\tctx.stroke();\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\t'fill-rect'(props) {\n\t\treturn ctx => {\n\t\t\tctx.save();\n\t\t\tif (props.color) {\n\t\t\t\tctx.fillStyle = props.color;\n\t\t\t}\n\t\t\tctx.fillRect(0, 0, props.w, props.h);\n\t\t\tdrawChildren(props, ctx);\n\t\t\tctx.restore();\n\t\t};\n\t},\n\n\tnothing() {\n\t\treturn () => {};\n\t},\n\n\t/*\n  * looks up primitive by name and returns a function that takes props\n  * this in turn returns a function that takes the canvas context and\n  * draws the primitive to the screen\n  */\n\t_lookup(name) {\n\t\tif (!(name in this)) {\n\t\t\tthrow new TypeError('Unrecognized primitive type: ' + name);\n\t\t}\n\t\treturn this[name];\n\t}\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (primitives);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3ByaW1pdGl2ZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9wcmltaXRpdmVzLmpzP2NhMDIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZHJhd0NoaWxkcmVuIChwcm9wcywgY3R4KSB7XG5cdGlmIChwcm9wcy5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Zm9yIChjb25zdCBjaGlsZE5vZGUgb2YgcHJvcHMuY2hpbGRyZW4pIHtcblx0XHRcdGNoaWxkTm9kZS5kcmF3KGN0eClcblx0XHR9XG5cdH1cbn1cblxuY29uc3QgcHJpbWl0aXZlcyA9IHtcblx0Lypcblx0ICogcmVuZGVycyBpdHMgY2hpbGRyZW4gYW5kIGRvZXMgbm90aGluZyBlbHNlXG5cdCAqL1xuXHRsYXllciAocHJvcHMpIHtcblx0XHRyZXR1cm4gY3R4ID0+IHtcblx0XHRcdGN0eC5zYXZlKClcblx0XHRcdGRyYXdDaGlsZHJlbihwcm9wcywgY3R4KVxuXHRcdFx0Y3R4LnJlc3RvcmUoKVxuXHRcdH1cblx0fSxcblx0Lypcblx0ICogY3JlYXRlcyBhIHJlY3Rhbmd1bGFyIHBhdGggZm9yIHN0cm9raW5nL2ZpbGxpbmdcblx0ICogY2FsbHMgY3R4LnJlY3QoKSB0aGVuIHJlbmRlcnMgYW55IGNoaWxkcmVuXG5cdCAqL1xuXHRyZWN0IChwcm9wcykge1xuXHRcdHJldHVybiBjdHggPT4ge1xuXHRcdFx0Y3R4LnNhdmUoKVxuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpXG5cdFx0XHRjdHgucmVjdCgwLCAwLCBwcm9wcy53LCBwcm9wcy5oKVxuXHRcdFx0ZHJhd0NoaWxkcmVuKHByb3BzLCBjdHgpXG5cdFx0XHRjdHgucmVzdG9yZSgpXG5cdFx0fVxuXHR9LFxuXHQvKlxuXHQgKiBmaWxscyBpdHMgZW5jbG9zaW5nIHBhdGhcblx0ICogY2FsbHMgY3R4LmZpbGwoKVxuXHQgKi9cblx0ZmlsbCAocHJvcHMpIHtcblx0XHRyZXR1cm4gY3R4ID0+IHtcblx0XHRcdGN0eC5zYXZlKClcblx0XHRcdGlmIChwcm9wcy5jb2xvcikge1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gcHJvcHMuY29sb3Jcblx0XHRcdH1cblx0XHRcdGN0eC5maWxsKClcblx0XHRcdGRyYXdDaGlsZHJlbihwcm9wcywgY3R4KVxuXHRcdFx0Y3R4LnJlc3RvcmUoKVxuXHRcdH1cblx0fSxcblxuXHRzdHJva2UgKHByb3BzKSB7XG5cdFx0cmV0dXJuIGN0eCA9PiB7XG5cdFx0XHRjdHguc2F2ZSgpXG5cdFx0XHRpZiAocHJvcHMuY29sb3IpIHtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gcHJvcHMuY29sb3Jcblx0XHRcdH1cblx0XHRcdGN0eC5zdHJva2UoKVxuXHRcdFx0ZHJhd0NoaWxkcmVuKHByb3BzLCBjdHgpXG5cdFx0XHRjdHgucmVzdG9yZSgpXG5cdFx0fVxuXHR9LFxuXHRcblx0J2ZpbGwtcmVjdCcgKHByb3BzKSB7XG5cdFx0cmV0dXJuIGN0eCA9PiB7XG5cdFx0XHRjdHguc2F2ZSgpXG5cdFx0XHRpZiAocHJvcHMuY29sb3IpIHtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHByb3BzLmNvbG9yXG5cdFx0XHR9XG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgcHJvcHMudywgcHJvcHMuaClcblx0XHRcdGRyYXdDaGlsZHJlbihwcm9wcywgY3R4KVxuXHRcdFx0Y3R4LnJlc3RvcmUoKVxuXHRcdH1cblx0fSxcblxuXHRub3RoaW5nICgpIHtcblx0XHRyZXR1cm4gKCkgPT4ge31cblx0fSxcblxuXHQvKlxuXHQgKiBsb29rcyB1cCBwcmltaXRpdmUgYnkgbmFtZSBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgcHJvcHNcblx0ICogdGhpcyBpbiB0dXJuIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjYW52YXMgY29udGV4dCBhbmRcblx0ICogZHJhd3MgdGhlIHByaW1pdGl2ZSB0byB0aGUgc2NyZWVuXG5cdCAqL1xuXHRfbG9va3VwIChuYW1lKSB7XG5cdFx0aWYgKCEobmFtZSBpbiB0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWNvZ25pemVkIHByaW1pdGl2ZSB0eXBlOiAnICsgbmFtZSlcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXNbbmFtZV1cblx0fSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJpbWl0aXZlc1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlFQTtBQUNBO0FBZ0ZBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/primitives.js\n");

/***/ }),

/***/ "./src/lib/scheduler.js":
/*!******************************!*\
  !*** ./src/lib/scheduler.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// schedules updates, moves, renders, and draws\nfunction Scheduler(screen) {\n\tconst IDLE = 0;\n\tconst PENDING = 1;\n\tconst UPDATING = 2;\n\tconst MOVING = 3;\n\tconst RERENDERING = 4;\n\tconst DRAWING = 5;\n\n\tlet state = IDLE;\n\tlet currentTickShould = [];\n\tlet nextTickShould = [];\n\n\tconst actions = [];\n\tactions[UPDATING] = time => {\n\t\tscreen.root.recursiveUpdate(time);\n\t};\n\tactions[MOVING] = () => {\n\t\tscreen.root.recursiveMove();\n\t\tcurrentTickShould[DRAWING] = true;\n\t};\n\tactions[RERENDERING] = () => {\n\t\tscreen.root.rerender();\n\t\tcurrentTickShould[DRAWING] = true;\n\t};\n\tactions[DRAWING] = () => {\n\t\tscreen.draw();\n\t};\n\n\tlet lastTime = null;\n\n\tfunction tick(time) {\n\t\tconst elapsed = lastTime === null ? 0 : time - lastTime;\n\t\tif (elapsed > 17) {\n\t\t\tconsole.log('Slowed down!');\n\t\t\tconsole.log(elapsed);\n\t\t}\n\t\tlastTime = time;\n\n\t\tfor (state = UPDATING; state <= DRAWING; state++) {\n\t\t\tif (currentTickShould[state]) {\n\t\t\t\tactions[state](elapsed);\n\t\t\t}\n\t\t}\n\n\t\tif (nextTickShould.length > 0) {\n\t\t\tcurrentTickShould = nextTickShould;\n\t\t\tnextTickShould = [];\n\t\t\twindow.requestAnimationFrame(tick);\n\t\t} else {\n\t\t\tlastTime = null;\n\t\t\tcurrentTickShould = [];\n\t\t\tstate = IDLE;\n\t\t}\n\t}\n\n\tfunction ScheduleAction(STATE) {\n\t\treturn node => {\n\t\t\tif (state === IDLE) {\n\t\t\t\tcurrentTickShould[STATE] = true;\n\t\t\t\tstate = PENDING;\n\t\t\t\twindow.requestAnimationFrame(tick);\n\t\t\t} else if (state < STATE) {\n\t\t\t\tcurrentTickShould[STATE] = true;\n\t\t\t} else {\n\t\t\t\tnextTickShould[STATE] = true;\n\t\t\t}\n\t\t};\n\t}\n\n\tthis.scheduleUpdate = ScheduleAction(UPDATING);\n\n\tthis.scheduleMove = ScheduleAction(MOVING);\n\n\tthis.scheduleRender = ScheduleAction(RERENDERING);\n\n\tthis.scheduleDraw = ScheduleAction(DRAWING);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Scheduler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3NjaGVkdWxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL3NjaGVkdWxlci5qcz82OWJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNjaGVkdWxlcyB1cGRhdGVzLCBtb3ZlcywgcmVuZGVycywgYW5kIGRyYXdzXG5mdW5jdGlvbiBTY2hlZHVsZXIgKHNjcmVlbikge1xuXHRjb25zdCBJRExFID0gMFxuXHRjb25zdCBQRU5ESU5HID0gMVxuXHRjb25zdCBVUERBVElORyA9IDJcblx0Y29uc3QgTU9WSU5HID0gM1xuXHRjb25zdCBSRVJFTkRFUklORyA9IDRcblx0Y29uc3QgRFJBV0lORyA9IDVcblxuXHRsZXQgc3RhdGUgPSBJRExFXG5cdGxldCBjdXJyZW50VGlja1Nob3VsZCA9IFtdXG5cdGxldCBuZXh0VGlja1Nob3VsZCA9IFtdXG5cblx0Y29uc3QgYWN0aW9ucyA9IFtdXG5cdGFjdGlvbnNbVVBEQVRJTkddID0gdGltZSA9PiB7XG5cdFx0c2NyZWVuLnJvb3QucmVjdXJzaXZlVXBkYXRlKHRpbWUpXG5cdH1cblx0YWN0aW9uc1tNT1ZJTkddID0gKCkgPT4ge1xuXHRcdHNjcmVlbi5yb290LnJlY3Vyc2l2ZU1vdmUoKVxuXHRcdGN1cnJlbnRUaWNrU2hvdWxkW0RSQVdJTkddID0gdHJ1ZVxuXHR9XG5cdGFjdGlvbnNbUkVSRU5ERVJJTkddID0gKCkgPT4ge1xuXHRcdHNjcmVlbi5yb290LnJlcmVuZGVyKClcblx0XHRjdXJyZW50VGlja1Nob3VsZFtEUkFXSU5HXSA9IHRydWVcblx0fVxuXHRhY3Rpb25zW0RSQVdJTkddID0gKCkgPT4ge1xuXHRcdHNjcmVlbi5kcmF3KClcblx0fVxuXG5cdGxldCBsYXN0VGltZSA9IG51bGxcblxuXHRmdW5jdGlvbiB0aWNrICh0aW1lKSB7XG5cdFx0Y29uc3QgZWxhcHNlZCA9IGxhc3RUaW1lID09PSBudWxsID8gMCA6IHRpbWUgLSBsYXN0VGltZVxuXHRcdGlmIChlbGFwc2VkID4gMTcpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdTbG93ZWQgZG93biEnKVxuXHRcdFx0Y29uc29sZS5sb2coZWxhcHNlZClcblx0XHR9XG5cdFx0bGFzdFRpbWUgPSB0aW1lXG5cblx0XHRmb3IgKHN0YXRlID0gVVBEQVRJTkc7IHN0YXRlIDw9IERSQVdJTkc7IHN0YXRlKyspIHtcblx0XHRcdGlmIChjdXJyZW50VGlja1Nob3VsZFtzdGF0ZV0pIHtcblx0XHRcdFx0YWN0aW9uc1tzdGF0ZV0oZWxhcHNlZClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobmV4dFRpY2tTaG91bGQubGVuZ3RoID4gMCkge1xuXHRcdFx0Y3VycmVudFRpY2tTaG91bGQgPSBuZXh0VGlja1Nob3VsZFxuXHRcdFx0bmV4dFRpY2tTaG91bGQgPSBbXVxuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsYXN0VGltZSA9IG51bGxcblx0XHRcdGN1cnJlbnRUaWNrU2hvdWxkID0gW11cblx0XHRcdHN0YXRlID0gSURMRVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFNjaGVkdWxlQWN0aW9uIChTVEFURSkge1xuXHRcdHJldHVybiBub2RlID0+IHtcblx0XHRcdGlmIChzdGF0ZSA9PT0gSURMRSkge1xuXHRcdFx0XHRjdXJyZW50VGlja1Nob3VsZFtTVEFURV0gPSB0cnVlXG5cdFx0XHRcdHN0YXRlID0gUEVORElOR1xuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXG5cdFx0XHR9IGVsc2UgaWYgKHN0YXRlIDwgU1RBVEUpIHtcblx0XHRcdFx0Y3VycmVudFRpY2tTaG91bGRbU1RBVEVdID0gdHJ1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV4dFRpY2tTaG91bGRbU1RBVEVdID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBTY2hlZHVsZUFjdGlvbihVUERBVElORylcblxuXHR0aGlzLnNjaGVkdWxlTW92ZSA9IFNjaGVkdWxlQWN0aW9uKE1PVklORylcblxuXHR0aGlzLnNjaGVkdWxlUmVuZGVyID0gU2NoZWR1bGVBY3Rpb24oUkVSRU5ERVJJTkcpXG5cblx0dGhpcy5zY2hlZHVsZURyYXcgPSBTY2hlZHVsZUFjdGlvbihEUkFXSU5HKVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsZXJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/scheduler.js\n");

/***/ }),

/***/ "./src/lib/screen.js":
/*!***************************!*\
  !*** ./src/lib/screen.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ \"./node_modules/rbush/index.js\");\n/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// Holds the tree that contains all components\n//\n// used for drawing and collision detection\n//\n// screen.root is the root element of the application\nfunction Screen(ctx) {\n\t// the drawing context of the canvas\n\tthis.ctx = ctx;\n\t// map from component to screen element\n\tthis.map = new Map();\n\t// r-tree for calculating intersections\n\tthis.tree = rbush__WEBPACK_IMPORTED_MODULE_0___default()();\n\n\t// screen is the parent of the root node so it must have coordinates\n\tthis.screenX = 0;\n\tthis.screenY = 0;\n}\n\nScreen.prototype.setRootElement = function (node) {\n\tthis.root = node;\n\tthis.root.setParent(this);\n\tthis.root.recursiveRender();\n\tthis.draw();\n};\n\nScreen.prototype.setDimensions = function (width, height) {\n\tthis.w = width;\n\tthis.h = height;\n};\n\nScreen.prototype.rebuildRTree = function () {\n\t// begin construction of a new component -> screen object map\n\tthis.newMap = new Map();\n\t// empty the r tree\n\tthis.tree.clear();\n\t// reset z index\n\tthis.zIndex = 0;\n\n\t// recursively add all nodes to the r tree\n\tthis.addToRTree(this.root);\n\n\t// only components which were not added to the new map will be garbage collected\n\tthis.map = this.newMap;\n};\n\nScreen.prototype.addToRTree = function (node) {\n\tif (node.component) {\n\t\tlet screenObj = this.map.get(node.component);\n\t\tif (screenObj) {\n\t\t\tscreenObj.update(node.screenX, node.screenY, this.zIndex++);\n\t\t} else {\n\t\t\tscreenObj = new ScreenObject(node.component, node.screenX, node.screenY, this.zIndex++);\n\t\t}\n\t\t// addToRTree is called as part of rebuilding the r-tree so it operates on the new map rather than the map\n\t\tthis.newMap.set(node.component, screenObj);\n\t\t// the tree has been cleared so we add the screen object to the fresh tree\n\t\tthis.tree.insert(screenObj);\n\t}\n\t// recursively add all descendents of the node\n\t// a node's rendered result is either a Node or a Function. If it's not a function,\n\t// it's a Node\n\t//\n\t// ... kind of hacky, but it lets us avoid the circular import of Node -> Screen -> Node\n\tif (!(node.rendered instanceof Function)) {\n\t\tthis.addToRTree(node.rendered);\n\t}\n\tif (node.children) {\n\t\t//node.children.forEach(this.addToRTree, this)\n\t\tnode.children.forEach(child => {\n\t\t\tthis.addToRTree(child);\n\t\t});\n\t}\n};\n\nScreen.prototype.draw = function () {\n\tthis.rebuildRTree();\n\t// TODO\n\t// obviously this clear screen should be more sophisticated\n\tthis.ctx.fillStyle = '#ffffff';\n\tthis.ctx.fillRect(0, 0, 1000, 1000);\n\tthis.root.draw(this.ctx);\n};\n\n// this may be part of scheduler updates\nScreen.prototype.getIntersections = function (el) {\n\tconst screenObj = this.map.get(el);\n\treturn this.tree.search(screenObj).reduce((collisions, screenObj) => {\n\t\tconst collision = {\n\t\t\tx: screenObj.minX,\n\t\t\ty: screenObj.minY,\n\t\t\tw: screenObj.maxX - screenObj.minX,\n\t\t\th: screenObj.maxY - screenObj.minY,\n\t\t\ttop: screenObj.minY,\n\t\t\tright: screenObj.maxX,\n\t\t\tbottom: screenObj.maxY,\n\t\t\tleft: screenObj.minX,\n\t\t\tcomponent: screenObj.component,\n\t\t\tdx: screenObj.dx,\n\t\t\tdy: screenObj.dy\n\t\t};\n\t\tif (screenObj.component !== el) {\n\t\t\tcollisions.push(collision);\n\t\t}\n\t\treturn collisions;\n\t}, []);\n};\n\n// returns only the top most intersecting component\nScreen.prototype.queryPoint = function (x, y) {\n\tconst collisions = this.tree.search({\n\t\tminX: x,\n\t\tmaxX: x,\n\t\tminY: y,\n\t\tmaxY: y\n\t});\n\n\tif (collisions.length === 0) {\n\t\treturn null;\n\t}\n\n\tconst top = collisions.reduce((accum, current) => {\n\t\tif (current.z > accum.z) {\n\t\t\treturn current;\n\t\t}\n\t\treturn accum;\n\t});\n\n\treturn top.component;\n};\n\n// returns all elements at a given query point in descending Z order\nScreen.prototype.queryPointAll = function (x, y) {\n\treturn this.tree.search({\n\t\tminX: x,\n\t\tmaxX: x,\n\t\tminY: y,\n\t\tmaxY: y\n\t}).sort((a, b) => {\n\t\treturn b.z - a.z;\n\t}).map(screenObj => screenObj.component);\n};\n\n// returns all intersections\nScreen.prototype.query = function (q) {\n\treturn this.tree.search({\n\t\tminX: q.x,\n\t\tmaxX: q.x + q.w,\n\t\tminY: q.y,\n\t\tmaxY: q.y + q.h\n\t}).map(screenObj => screenObj.component);\n};\n\nfunction ScreenObject(component, x, y, z) {\n\t// set component\n\tthis.component = component;\n\t// assign minX, maxX, minY, maxY, and z\n\tthis.update(x, y, z);\n}\n\nScreenObject.prototype.update = function (x, y, z) {\n\tthis.dx = x - this.minX;\n\tthis.dy = y - this.minY;\n\tthis.minX = x;\n\tthis.maxX = x + this.component.w;\n\tthis.minY = y;\n\tthis.maxY = y + this.component.h;\n\tthis.z = z;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Screen);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3NjcmVlbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGliL3NjcmVlbi5qcz9lYjZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByYnVzaCBmcm9tICdyYnVzaCdcblxuLy8gSG9sZHMgdGhlIHRyZWUgdGhhdCBjb250YWlucyBhbGwgY29tcG9uZW50c1xuLy9cbi8vIHVzZWQgZm9yIGRyYXdpbmcgYW5kIGNvbGxpc2lvbiBkZXRlY3Rpb25cbi8vXG4vLyBzY3JlZW4ucm9vdCBpcyB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBhcHBsaWNhdGlvblxuZnVuY3Rpb24gU2NyZWVuIChjdHgpIHtcblx0Ly8gdGhlIGRyYXdpbmcgY29udGV4dCBvZiB0aGUgY2FudmFzXG5cdHRoaXMuY3R4ID0gY3R4XG5cdC8vIG1hcCBmcm9tIGNvbXBvbmVudCB0byBzY3JlZW4gZWxlbWVudFxuXHR0aGlzLm1hcCA9IG5ldyBNYXAoKVxuXHQvLyByLXRyZWUgZm9yIGNhbGN1bGF0aW5nIGludGVyc2VjdGlvbnNcblx0dGhpcy50cmVlID0gcmJ1c2goKVxuXG5cdC8vIHNjcmVlbiBpcyB0aGUgcGFyZW50IG9mIHRoZSByb290IG5vZGUgc28gaXQgbXVzdCBoYXZlIGNvb3JkaW5hdGVzXG5cdHRoaXMuc2NyZWVuWCA9IDBcblx0dGhpcy5zY3JlZW5ZID0gMFxufVxuXG5TY3JlZW4ucHJvdG90eXBlLnNldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0dGhpcy5yb290ID0gbm9kZVxuXHR0aGlzLnJvb3Quc2V0UGFyZW50KHRoaXMpXG5cdHRoaXMucm9vdC5yZWN1cnNpdmVSZW5kZXIoKVxuXHR0aGlzLmRyYXcoKVxufVxuXG5TY3JlZW4ucHJvdG90eXBlLnNldERpbWVuc2lvbnMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuXHR0aGlzLncgPSB3aWR0aFxuXHR0aGlzLmggPSBoZWlnaHRcbn1cblxuU2NyZWVuLnByb3RvdHlwZS5yZWJ1aWxkUlRyZWUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIGJlZ2luIGNvbnN0cnVjdGlvbiBvZiBhIG5ldyBjb21wb25lbnQgLT4gc2NyZWVuIG9iamVjdCBtYXBcblx0dGhpcy5uZXdNYXAgPSBuZXcgTWFwKClcblx0Ly8gZW1wdHkgdGhlIHIgdHJlZVxuXHR0aGlzLnRyZWUuY2xlYXIoKVxuXHQvLyByZXNldCB6IGluZGV4XG5cdHRoaXMuekluZGV4ID0gMFxuXG5cdC8vIHJlY3Vyc2l2ZWx5IGFkZCBhbGwgbm9kZXMgdG8gdGhlIHIgdHJlZVxuXHR0aGlzLmFkZFRvUlRyZWUodGhpcy5yb290KVxuXG5cdC8vIG9ubHkgY29tcG9uZW50cyB3aGljaCB3ZXJlIG5vdCBhZGRlZCB0byB0aGUgbmV3IG1hcCB3aWxsIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdHRoaXMubWFwID0gdGhpcy5uZXdNYXBcbn1cblxuU2NyZWVuLnByb3RvdHlwZS5hZGRUb1JUcmVlID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0aWYgKG5vZGUuY29tcG9uZW50KSB7XG5cdFx0bGV0IHNjcmVlbk9iaiA9IHRoaXMubWFwLmdldChub2RlLmNvbXBvbmVudClcblx0XHRpZiAoc2NyZWVuT2JqKSB7XG5cdFx0XHRzY3JlZW5PYmoudXBkYXRlKG5vZGUuc2NyZWVuWCwgbm9kZS5zY3JlZW5ZLCB0aGlzLnpJbmRleCsrKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzY3JlZW5PYmogPSBuZXcgU2NyZWVuT2JqZWN0KG5vZGUuY29tcG9uZW50LCBub2RlLnNjcmVlblgsIG5vZGUuc2NyZWVuWSwgdGhpcy56SW5kZXgrKylcblx0XHR9XG5cdFx0Ly8gYWRkVG9SVHJlZSBpcyBjYWxsZWQgYXMgcGFydCBvZiByZWJ1aWxkaW5nIHRoZSByLXRyZWUgc28gaXQgb3BlcmF0ZXMgb24gdGhlIG5ldyBtYXAgcmF0aGVyIHRoYW4gdGhlIG1hcFxuXHRcdHRoaXMubmV3TWFwLnNldChub2RlLmNvbXBvbmVudCwgc2NyZWVuT2JqKVxuXHRcdC8vIHRoZSB0cmVlIGhhcyBiZWVuIGNsZWFyZWQgc28gd2UgYWRkIHRoZSBzY3JlZW4gb2JqZWN0IHRvIHRoZSBmcmVzaCB0cmVlXG5cdFx0dGhpcy50cmVlLmluc2VydChzY3JlZW5PYmopXG5cdH1cblx0Ly8gcmVjdXJzaXZlbHkgYWRkIGFsbCBkZXNjZW5kZW50cyBvZiB0aGUgbm9kZVxuXHQvLyBhIG5vZGUncyByZW5kZXJlZCByZXN1bHQgaXMgZWl0aGVyIGEgTm9kZSBvciBhIEZ1bmN0aW9uLiBJZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLFxuXHQvLyBpdCdzIGEgTm9kZVxuXHQvL1xuXHQvLyAuLi4ga2luZCBvZiBoYWNreSwgYnV0IGl0IGxldHMgdXMgYXZvaWQgdGhlIGNpcmN1bGFyIGltcG9ydCBvZiBOb2RlIC0+IFNjcmVlbiAtPiBOb2RlXG5cdGlmICghKG5vZGUucmVuZGVyZWQgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcblx0XHR0aGlzLmFkZFRvUlRyZWUobm9kZS5yZW5kZXJlZClcblx0fVxuXHRpZiAobm9kZS5jaGlsZHJlbikge1xuXHRcdC8vbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHRoaXMuYWRkVG9SVHJlZSwgdGhpcylcblx0XHRub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0dGhpcy5hZGRUb1JUcmVlKGNoaWxkKVxuXHRcdH0pXG5cdH1cbn1cblxuU2NyZWVuLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnJlYnVpbGRSVHJlZSgpXG5cdC8vIFRPRE9cblx0Ly8gb2J2aW91c2x5IHRoaXMgY2xlYXIgc2NyZWVuIHNob3VsZCBiZSBtb3JlIHNvcGhpc3RpY2F0ZWRcblx0dGhpcy5jdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnXG5cdHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEwMDAsIDEwMDApXG5cdHRoaXMucm9vdC5kcmF3KHRoaXMuY3R4KVxufVxuXG4vLyB0aGlzIG1heSBiZSBwYXJ0IG9mIHNjaGVkdWxlciB1cGRhdGVzXG5TY3JlZW4ucHJvdG90eXBlLmdldEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAoZWwpIHtcblx0Y29uc3Qgc2NyZWVuT2JqID0gdGhpcy5tYXAuZ2V0KGVsKVxuXHRyZXR1cm4gdGhpcy50cmVlLnNlYXJjaChzY3JlZW5PYmopLnJlZHVjZSgoY29sbGlzaW9ucywgc2NyZWVuT2JqKSA9PiB7XG5cdFx0Y29uc3QgY29sbGlzaW9uID0ge1xuXHRcdFx0eDogc2NyZWVuT2JqLm1pblgsXG5cdFx0XHR5OiBzY3JlZW5PYmoubWluWSxcblx0XHRcdHc6IHNjcmVlbk9iai5tYXhYIC0gc2NyZWVuT2JqLm1pblgsXG5cdFx0XHRoOiBzY3JlZW5PYmoubWF4WSAtIHNjcmVlbk9iai5taW5ZLFxuXHRcdFx0dG9wOiBzY3JlZW5PYmoubWluWSxcblx0XHRcdHJpZ2h0OiBzY3JlZW5PYmoubWF4WCxcblx0XHRcdGJvdHRvbTogc2NyZWVuT2JqLm1heFksXG5cdFx0XHRsZWZ0OiBzY3JlZW5PYmoubWluWCxcblx0XHRcdGNvbXBvbmVudDogc2NyZWVuT2JqLmNvbXBvbmVudCxcblx0XHRcdGR4OiBzY3JlZW5PYmouZHgsXG5cdFx0XHRkeTogc2NyZWVuT2JqLmR5LFxuXHRcdH1cblx0XHRpZiAoc2NyZWVuT2JqLmNvbXBvbmVudCAhPT0gZWwpIHtcblx0XHRcdGNvbGxpc2lvbnMucHVzaChjb2xsaXNpb24pXG5cdFx0fVxuXHRcdHJldHVybiBjb2xsaXNpb25zXG5cdH0sIFtdKVxufVxuXG4vLyByZXR1cm5zIG9ubHkgdGhlIHRvcCBtb3N0IGludGVyc2VjdGluZyBjb21wb25lbnRcblNjcmVlbi5wcm90b3R5cGUucXVlcnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG5cdGNvbnN0IGNvbGxpc2lvbnMgPSB0aGlzLnRyZWUuc2VhcmNoKHtcblx0XHRtaW5YOiB4LFxuXHRcdG1heFg6IHgsXG5cdFx0bWluWTogeSxcblx0XHRtYXhZOiB5LFxuXHR9KVxuXG5cdGlmIChjb2xsaXNpb25zLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBudWxsXG5cdH1cblxuXHRjb25zdCB0b3AgPSBjb2xsaXNpb25zLnJlZHVjZSgoYWNjdW0sIGN1cnJlbnQpID0+IHtcblx0XHRpZiAoY3VycmVudC56ID4gYWNjdW0ueikge1xuXHRcdFx0cmV0dXJuIGN1cnJlbnRcblx0XHR9XG5cdFx0cmV0dXJuIGFjY3VtXG5cdH0pXG5cblx0cmV0dXJuIHRvcC5jb21wb25lbnRcbn1cblxuLy8gcmV0dXJucyBhbGwgZWxlbWVudHMgYXQgYSBnaXZlbiBxdWVyeSBwb2ludCBpbiBkZXNjZW5kaW5nIFogb3JkZXJcblNjcmVlbi5wcm90b3R5cGUucXVlcnlQb2ludEFsbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG5cdHJldHVybiB0aGlzLnRyZWUuc2VhcmNoKHtcblx0XHRtaW5YOiB4LFxuXHRcdG1heFg6IHgsXG5cdFx0bWluWTogeSxcblx0XHRtYXhZOiB5LFxuXHR9KS5zb3J0KChhLCBiKSA9PiB7XG5cdFx0cmV0dXJuIGIueiAtIGEuelxuXHR9KS5tYXAoc2NyZWVuT2JqID0+IHNjcmVlbk9iai5jb21wb25lbnQpXG59XG5cbi8vIHJldHVybnMgYWxsIGludGVyc2VjdGlvbnNcblNjcmVlbi5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocSkge1xuXHRyZXR1cm4gdGhpcy50cmVlLnNlYXJjaCh7XG5cdFx0bWluWDogcS54LFxuXHRcdG1heFg6IHEueCArIHEudyxcblx0XHRtaW5ZOiBxLnksXG5cdFx0bWF4WTogcS55ICsgcS5oLFxuXHR9KS5tYXAoc2NyZWVuT2JqID0+IHNjcmVlbk9iai5jb21wb25lbnQpXG59XG5cbmZ1bmN0aW9uIFNjcmVlbk9iamVjdCAoY29tcG9uZW50LCB4LCB5LCB6KSB7XG5cdC8vIHNldCBjb21wb25lbnRcblx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnRcblx0Ly8gYXNzaWduIG1pblgsIG1heFgsIG1pblksIG1heFksIGFuZCB6XG5cdHRoaXMudXBkYXRlKHgsIHksIHopXG59XG5cblNjcmVlbk9iamVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHgsIHksIHopIHtcblx0dGhpcy5keCA9IHggLSB0aGlzLm1pblhcblx0dGhpcy5keSA9IHkgLSB0aGlzLm1pbllcblx0dGhpcy5taW5YID0geFxuXHR0aGlzLm1heFggPSB4ICsgdGhpcy5jb21wb25lbnQud1xuXHR0aGlzLm1pblkgPSB5XG5cdHRoaXMubWF4WSA9IHkgKyB0aGlzLmNvbXBvbmVudC5oXG5cdHRoaXMueiA9IHpcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2NyZWVuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/screen.js\n");

/***/ }),

/***/ "./src/lib/structures.js":
/*!*******************************!*\
  !*** ./src/lib/structures.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction MultiMap() {\n\tthis.constructorMap = new Map();\n}\n\nMultiMap.prototype.get = function (component) {\n\tconst componentMap = this.constructorMap.get(component.constructor);\n\treturn componentMap.get(component);\n};\n\nMultiMap.prototype.set = function (component, value) {\n\tconst componentMap = this.constructorMap.get(component.constructor) || new Map();\n\tthis.constructorMap.set(component.constructor, componentMap);\n\tcomponentMap.set(component, value);\n};\n\nMultiMap.prototype.getAll = function (constructor) {\n\treturn this.constructorMap.get(constructor);\n};\n\nMultiMap.prototype.delete = function (component) {\n\tconst componentMap = this.constructorMap.get(component.constructor);\n\tif (componentMap) {\n\t\tcomponentMap.delete(component);\n\t}\n};\n\nMultiMap.prototype.forEach = function (fn) {\n\tthis.constructorMap.forEach((map, constructor) => {\n\t\tmap.forEach((val, component) => {\n\t\t\tfn(val, component, constructor);\n\t\t});\n\t});\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n\tMultiMap\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL3N0cnVjdHVyZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9zdHJ1Y3R1cmVzLmpzP2VmMGEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gTXVsdGlNYXAgKCkge1xuXHR0aGlzLmNvbnN0cnVjdG9yTWFwID0gbmV3IE1hcCAoKVxufVxuXG5NdWx0aU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuXHRjb25zdCBjb21wb25lbnRNYXAgPSB0aGlzLmNvbnN0cnVjdG9yTWFwLmdldChjb21wb25lbnQuY29uc3RydWN0b3IpXG5cdHJldHVybiBjb21wb25lbnRNYXAuZ2V0KGNvbXBvbmVudClcbn1cblxuTXVsdGlNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHZhbHVlKSB7XG5cdGNvbnN0IGNvbXBvbmVudE1hcCA9IHRoaXMuY29uc3RydWN0b3JNYXAuZ2V0KGNvbXBvbmVudC5jb25zdHJ1Y3RvcikgfHwgbmV3IE1hcCgpXG5cdHRoaXMuY29uc3RydWN0b3JNYXAuc2V0KGNvbXBvbmVudC5jb25zdHJ1Y3RvciwgY29tcG9uZW50TWFwKVxuXHRjb21wb25lbnRNYXAuc2V0KGNvbXBvbmVudCwgdmFsdWUpXG59XG5cbk11bHRpTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JNYXAuZ2V0KGNvbnN0cnVjdG9yKVxufVxuXG5NdWx0aU1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuXHRjb25zdCBjb21wb25lbnRNYXAgPSB0aGlzLmNvbnN0cnVjdG9yTWFwLmdldChjb21wb25lbnQuY29uc3RydWN0b3IpXG5cdGlmIChjb21wb25lbnRNYXApIHtcblx0XHRjb21wb25lbnRNYXAuZGVsZXRlKGNvbXBvbmVudClcblx0fVxufVxuXG5NdWx0aU1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikge1xuXHR0aGlzLmNvbnN0cnVjdG9yTWFwLmZvckVhY2goKG1hcCwgY29uc3RydWN0b3IpID0+IHtcblx0XHRtYXAuZm9yRWFjaCgodmFsLCBjb21wb25lbnQpID0+IHtcblx0XHRcdGZuKHZhbCwgY29tcG9uZW50LCBjb25zdHJ1Y3Rvcilcblx0XHR9KVxuXHR9KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG5cdE11bHRpTWFwLFxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/structures.js\n");

/***/ })

/******/ });